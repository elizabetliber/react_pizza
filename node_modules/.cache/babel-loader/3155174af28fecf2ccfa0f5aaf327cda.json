{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nexports = module.exports = function historyApiFallback(options) {\n  options = options || {};\n  var logger = getLogger(options);\n  return function (req, res, next) {\n    var headers = req.headers;\n\n    if (req.method !== 'GET') {\n      logger('Not rewriting', req.method, req.url, 'because the method is not GET.');\n      return next();\n    } else if (!headers || typeof headers.accept !== 'string') {\n      logger('Not rewriting', req.method, req.url, 'because the client did not send an HTTP accept header.');\n      return next();\n    } else if (headers.accept.indexOf('application/json') === 0) {\n      logger('Not rewriting', req.method, req.url, 'because the client prefers JSON.');\n      return next();\n    } else if (!acceptsHtml(headers.accept, options)) {\n      logger('Not rewriting', req.method, req.url, 'because the client does not accept HTML.');\n      return next();\n    }\n\n    var parsedUrl = url.parse(req.url);\n    var rewriteTarget;\n    options.rewrites = options.rewrites || [];\n\n    for (var i = 0; i < options.rewrites.length; i++) {\n      var rewrite = options.rewrites[i];\n      var match = parsedUrl.pathname.match(rewrite.from);\n\n      if (match !== null) {\n        rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req);\n\n        if (rewriteTarget.charAt(0) !== '/') {\n          logger('We recommend using an absolute path for the rewrite target.', 'Received a non-absolute rewrite target', rewriteTarget, 'for URL', req.url);\n        }\n\n        logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n        req.url = rewriteTarget;\n        return next();\n      }\n    }\n\n    var pathname = parsedUrl.pathname;\n\n    if (pathname.lastIndexOf('.') > pathname.lastIndexOf('/') && options.disableDotRule !== true) {\n      logger('Not rewriting', req.method, req.url, 'because the path includes a dot (.) character.');\n      return next();\n    }\n\n    rewriteTarget = options.index || '/index.html';\n    logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n    req.url = rewriteTarget;\n    next();\n  };\n};\n\nfunction evaluateRewriteRule(parsedUrl, match, rule, req) {\n  if (typeof rule === 'string') {\n    return rule;\n  } else if (typeof rule !== 'function') {\n    throw new Error('Rewrite rule can only be of type string or function.');\n  }\n\n  return rule({\n    parsedUrl: parsedUrl,\n    match: match,\n    request: req\n  });\n}\n\nfunction acceptsHtml(header, options) {\n  options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*'];\n\n  for (var i = 0; i < options.htmlAcceptHeaders.length; i++) {\n    if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getLogger(options) {\n  if (options && options.logger) {\n    return options.logger;\n  } else if (options && options.verbose) {\n    return console.log.bind(console);\n  }\n\n  return function () {};\n}","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/connect-history-api-fallback/lib/index.js"],"names":["url","require","exports","module","historyApiFallback","options","logger","getLogger","req","res","next","headers","method","accept","indexOf","acceptsHtml","parsedUrl","parse","rewriteTarget","rewrites","i","length","rewrite","match","pathname","from","evaluateRewriteRule","to","charAt","lastIndexOf","disableDotRule","index","rule","Error","request","header","htmlAcceptHeaders","verbose","console","log","bind"],"mappings":"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","sourcesContent":["'use strict';\n\nvar url = require('url');\n\nexports = module.exports = function historyApiFallback(options) {\n  options = options || {};\n  var logger = getLogger(options);\n\n  return function(req, res, next) {\n    var headers = req.headers;\n    if (req.method !== 'GET') {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the method is not GET.'\n      );\n      return next();\n    } else if (!headers || typeof headers.accept !== 'string') {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client did not send an HTTP accept header.'\n      );\n      return next();\n    } else if (headers.accept.indexOf('application/json') === 0) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client prefers JSON.'\n      );\n      return next();\n    } else if (!acceptsHtml(headers.accept, options)) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client does not accept HTML.'\n      );\n      return next();\n    }\n\n    var parsedUrl = url.parse(req.url);\n    var rewriteTarget;\n    options.rewrites = options.rewrites || [];\n    for (var i = 0; i < options.rewrites.length; i++) {\n      var rewrite = options.rewrites[i];\n      var match = parsedUrl.pathname.match(rewrite.from);\n      if (match !== null) {\n        rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req);\n\n        if(rewriteTarget.charAt(0) !== '/') {\n          logger(\n            'We recommend using an absolute path for the rewrite target.',\n            'Received a non-absolute rewrite target',\n            rewriteTarget,\n            'for URL',\n            req.url\n          );\n        }\n\n        logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n        req.url = rewriteTarget;\n        return next();\n      }\n    }\n\n    var pathname = parsedUrl.pathname;\n    if (pathname.lastIndexOf('.') > pathname.lastIndexOf('/') &&\n        options.disableDotRule !== true) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the path includes a dot (.) character.'\n      );\n      return next();\n    }\n\n    rewriteTarget = options.index || '/index.html';\n    logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n    req.url = rewriteTarget;\n    next();\n  };\n};\n\nfunction evaluateRewriteRule(parsedUrl, match, rule, req) {\n  if (typeof rule === 'string') {\n    return rule;\n  } else if (typeof rule !== 'function') {\n    throw new Error('Rewrite rule can only be of type string or function.');\n  }\n\n  return rule({\n    parsedUrl: parsedUrl,\n    match: match,\n    request: req\n  });\n}\n\nfunction acceptsHtml(header, options) {\n  options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*'];\n  for (var i = 0; i < options.htmlAcceptHeaders.length; i++) {\n    if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getLogger(options) {\n  if (options && options.logger) {\n    return options.logger;\n  } else if (options && options.verbose) {\n    return console.log.bind(console);\n  }\n  return function(){};\n}\n"]},"metadata":{},"sourceType":"script"}