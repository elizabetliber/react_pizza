{"ast":null,"code":"'use strict';\n\nvar bindexOf = require('buffer-indexof');\n\nvar equalSign = new Buffer('=');\n\nmodule.exports = function (opts) {\n  var binary = opts ? opts.binary : false;\n  var that = {};\n\n  that.encode = function (data, buf, offset) {\n    if (!data) data = {};\n    if (!offset) offset = 0;\n    if (!buf) buf = new Buffer(that.encodingLength(data) + offset);\n    var oldOffset = offset;\n    var keys = Object.keys(data);\n\n    if (keys.length === 0) {\n      buf[offset] = 0;\n      offset++;\n    }\n\n    keys.forEach(function (key) {\n      var val = data[key];\n      var oldOffset = offset;\n      offset++;\n\n      if (val === true) {\n        offset += buf.write(key, offset);\n      } else if (Buffer.isBuffer(val)) {\n        offset += buf.write(key + '=', offset);\n        var len = val.length;\n        val.copy(buf, offset, 0, len);\n        offset += len;\n      } else {\n        offset += buf.write(key + '=' + val, offset);\n      }\n\n      buf[oldOffset] = offset - oldOffset - 1;\n    });\n    that.encode.bytes = offset - oldOffset;\n    return buf;\n  };\n\n  that.decode = function (buf, offset, len) {\n    if (!offset) offset = 0;\n    if (!Number.isFinite(len)) len = buf.length;\n    var data = {};\n    var oldOffset = offset;\n\n    while (offset < len) {\n      var b = decodeBlock(buf, offset);\n      var i = bindexOf(b, equalSign);\n      offset += decodeBlock.bytes;\n      if (b.length === 0) continue; // ignore: most likely a single zero byte\n\n      if (i === -1) data[b.toString().toLowerCase()] = true;else if (i === 0) continue; // ignore: invalid key-length\n      else {\n          var key = b.slice(0, i).toString().toLowerCase();\n          if (key in data) continue; // ignore: overwriting not allowed\n\n          data[key] = binary ? b.slice(i + 1) : b.slice(i + 1).toString();\n        }\n    }\n\n    that.decode.bytes = offset - oldOffset;\n    return data;\n  };\n\n  that.encodingLength = function (data) {\n    if (!data) return 1; // 1 byte (single empty byte)\n\n    var keys = Object.keys(data);\n    if (keys.length === 0) return 1; // 1 byte (single empty byte)\n\n    return keys.reduce(function (total, key) {\n      var val = data[key];\n      total += Buffer.byteLength(key) + 1; // +1 byte to store field length\n\n      if (Buffer.isBuffer(val)) total += val.length + 1; // +1 byte to fit equal sign\n      else if (val !== true) total += Buffer.byteLength(String(val)) + 1; // +1 byte to fit equal sign\n\n      return total;\n    }, 0);\n  };\n\n  return that;\n};\n\nfunction decodeBlock(buf, offset) {\n  var len = buf[offset];\n  var to = offset + 1 + len;\n  var b = buf.slice(offset + 1, to > buf.length ? buf.length : to);\n  decodeBlock.bytes = len + 1;\n  return b;\n}","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/dns-txt/index.js"],"names":["bindexOf","require","equalSign","Buffer","module","exports","opts","binary","that","encode","data","buf","offset","encodingLength","oldOffset","keys","Object","length","forEach","key","val","write","isBuffer","len","copy","bytes","decode","Number","isFinite","b","decodeBlock","i","toString","toLowerCase","slice","reduce","total","byteLength","String","to"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;;AAEA,IAAIC,SAAS,GAAG,IAAIC,MAAJ,CAAW,GAAX,CAAhB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAC/B,MAAIC,MAAM,GAAGD,IAAI,GAAGA,IAAI,CAACC,MAAR,GAAiB,KAAlC;AACA,MAAIC,IAAI,GAAG,EAAX;;AAEAA,EAAAA,IAAI,CAACC,MAAL,GAAc,UAAUC,IAAV,EAAgBC,GAAhB,EAAqBC,MAArB,EAA6B;AACzC,QAAI,CAACF,IAAL,EAAWA,IAAI,GAAG,EAAP;AACX,QAAI,CAACE,MAAL,EAAaA,MAAM,GAAG,CAAT;AACb,QAAI,CAACD,GAAL,EAAUA,GAAG,GAAG,IAAIR,MAAJ,CAAWK,IAAI,CAACK,cAAL,CAAoBH,IAApB,IAA4BE,MAAvC,CAAN;AAEV,QAAIE,SAAS,GAAGF,MAAhB;AACA,QAAIG,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYL,IAAZ,CAAX;;AAEA,QAAIK,IAAI,CAACE,MAAL,KAAgB,CAApB,EAAuB;AACrBN,MAAAA,GAAG,CAACC,MAAD,CAAH,GAAc,CAAd;AACAA,MAAAA,MAAM;AACP;;AAEDG,IAAAA,IAAI,CAACG,OAAL,CAAa,UAAUC,GAAV,EAAe;AAC1B,UAAIC,GAAG,GAAGV,IAAI,CAACS,GAAD,CAAd;AACA,UAAIL,SAAS,GAAGF,MAAhB;AACAA,MAAAA,MAAM;;AAEN,UAAIQ,GAAG,KAAK,IAAZ,EAAkB;AAChBR,QAAAA,MAAM,IAAID,GAAG,CAACU,KAAJ,CAAUF,GAAV,EAAeP,MAAf,CAAV;AACD,OAFD,MAEO,IAAIT,MAAM,CAACmB,QAAP,CAAgBF,GAAhB,CAAJ,EAA0B;AAC/BR,QAAAA,MAAM,IAAID,GAAG,CAACU,KAAJ,CAAUF,GAAG,GAAG,GAAhB,EAAqBP,MAArB,CAAV;AACA,YAAIW,GAAG,GAAGH,GAAG,CAACH,MAAd;AACAG,QAAAA,GAAG,CAACI,IAAJ,CAASb,GAAT,EAAcC,MAAd,EAAsB,CAAtB,EAAyBW,GAAzB;AACAX,QAAAA,MAAM,IAAIW,GAAV;AACD,OALM,MAKA;AACLX,QAAAA,MAAM,IAAID,GAAG,CAACU,KAAJ,CAAUF,GAAG,GAAG,GAAN,GAAYC,GAAtB,EAA2BR,MAA3B,CAAV;AACD;;AAEDD,MAAAA,GAAG,CAACG,SAAD,CAAH,GAAiBF,MAAM,GAAGE,SAAT,GAAqB,CAAtC;AACD,KAjBD;AAmBAN,IAAAA,IAAI,CAACC,MAAL,CAAYgB,KAAZ,GAAoBb,MAAM,GAAGE,SAA7B;AACA,WAAOH,GAAP;AACD,GAlCD;;AAoCAH,EAAAA,IAAI,CAACkB,MAAL,GAAc,UAAUf,GAAV,EAAeC,MAAf,EAAuBW,GAAvB,EAA4B;AACxC,QAAI,CAACX,MAAL,EAAaA,MAAM,GAAG,CAAT;AACb,QAAI,CAACe,MAAM,CAACC,QAAP,CAAgBL,GAAhB,CAAL,EAA2BA,GAAG,GAAGZ,GAAG,CAACM,MAAV;AAC3B,QAAIP,IAAI,GAAG,EAAX;AACA,QAAII,SAAS,GAAGF,MAAhB;;AAEA,WAAOA,MAAM,GAAGW,GAAhB,EAAqB;AACnB,UAAIM,CAAC,GAAGC,WAAW,CAACnB,GAAD,EAAMC,MAAN,CAAnB;AACA,UAAImB,CAAC,GAAG/B,QAAQ,CAAC6B,CAAD,EAAI3B,SAAJ,CAAhB;AACAU,MAAAA,MAAM,IAAIkB,WAAW,CAACL,KAAtB;AAEA,UAAII,CAAC,CAACZ,MAAF,KAAa,CAAjB,EAAoB,SALD,CAKU;;AAC7B,UAAIc,CAAC,KAAK,CAAC,CAAX,EAAcrB,IAAI,CAACmB,CAAC,CAACG,QAAF,GAAaC,WAAb,EAAD,CAAJ,GAAmC,IAAnC,CAAd,KACK,IAAIF,CAAC,KAAK,CAAV,EAAa,SAAb,CAAsB;AAAtB,WACA;AACH,cAAIZ,GAAG,GAAGU,CAAC,CAACK,KAAF,CAAQ,CAAR,EAAWH,CAAX,EAAcC,QAAd,GAAyBC,WAAzB,EAAV;AACA,cAAId,GAAG,IAAIT,IAAX,EAAiB,SAFd,CAEuB;;AAC1BA,UAAAA,IAAI,CAACS,GAAD,CAAJ,GAAYZ,MAAM,GAAGsB,CAAC,CAACK,KAAF,CAAQH,CAAC,GAAG,CAAZ,CAAH,GAAoBF,CAAC,CAACK,KAAF,CAAQH,CAAC,GAAG,CAAZ,EAAeC,QAAf,EAAtC;AACD;AACF;;AAEDxB,IAAAA,IAAI,CAACkB,MAAL,CAAYD,KAAZ,GAAoBb,MAAM,GAAGE,SAA7B;AACA,WAAOJ,IAAP;AACD,GAvBD;;AAyBAF,EAAAA,IAAI,CAACK,cAAL,GAAsB,UAAUH,IAAV,EAAgB;AACpC,QAAI,CAACA,IAAL,EAAW,OAAO,CAAP,CADyB,CAChB;;AACpB,QAAIK,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYL,IAAZ,CAAX;AACA,QAAIK,IAAI,CAACE,MAAL,KAAgB,CAApB,EAAuB,OAAO,CAAP,CAHa,CAGJ;;AAChC,WAAOF,IAAI,CAACoB,MAAL,CAAY,UAAUC,KAAV,EAAiBjB,GAAjB,EAAsB;AACvC,UAAIC,GAAG,GAAGV,IAAI,CAACS,GAAD,CAAd;AACAiB,MAAAA,KAAK,IAAIjC,MAAM,CAACkC,UAAP,CAAkBlB,GAAlB,IAAyB,CAAlC,CAFuC,CAEH;;AACpC,UAAIhB,MAAM,CAACmB,QAAP,CAAgBF,GAAhB,CAAJ,EAA0BgB,KAAK,IAAIhB,GAAG,CAACH,MAAJ,GAAa,CAAtB,CAA1B,CAAkD;AAAlD,WACK,IAAIG,GAAG,KAAK,IAAZ,EAAkBgB,KAAK,IAAIjC,MAAM,CAACkC,UAAP,CAAkBC,MAAM,CAAClB,GAAD,CAAxB,IAAiC,CAA1C,CAJgB,CAI4B;;AACnE,aAAOgB,KAAP;AACD,KANM,EAMJ,CANI,CAAP;AAOD,GAXD;;AAaA,SAAO5B,IAAP;AACD,CA/ED;;AAiFA,SAASsB,WAAT,CAAsBnB,GAAtB,EAA2BC,MAA3B,EAAmC;AACjC,MAAIW,GAAG,GAAGZ,GAAG,CAACC,MAAD,CAAb;AACA,MAAI2B,EAAE,GAAG3B,MAAM,GAAG,CAAT,GAAaW,GAAtB;AACA,MAAIM,CAAC,GAAGlB,GAAG,CAACuB,KAAJ,CAAUtB,MAAM,GAAG,CAAnB,EAAsB2B,EAAE,GAAG5B,GAAG,CAACM,MAAT,GAAkBN,GAAG,CAACM,MAAtB,GAA+BsB,EAArD,CAAR;AACAT,EAAAA,WAAW,CAACL,KAAZ,GAAoBF,GAAG,GAAG,CAA1B;AACA,SAAOM,CAAP;AACD","sourcesContent":["'use strict'\n\nvar bindexOf = require('buffer-indexof')\n\nvar equalSign = new Buffer('=')\n\nmodule.exports = function (opts) {\n  var binary = opts ? opts.binary : false\n  var that = {}\n\n  that.encode = function (data, buf, offset) {\n    if (!data) data = {}\n    if (!offset) offset = 0\n    if (!buf) buf = new Buffer(that.encodingLength(data) + offset)\n\n    var oldOffset = offset\n    var keys = Object.keys(data)\n\n    if (keys.length === 0) {\n      buf[offset] = 0\n      offset++\n    }\n\n    keys.forEach(function (key) {\n      var val = data[key]\n      var oldOffset = offset\n      offset++\n\n      if (val === true) {\n        offset += buf.write(key, offset)\n      } else if (Buffer.isBuffer(val)) {\n        offset += buf.write(key + '=', offset)\n        var len = val.length\n        val.copy(buf, offset, 0, len)\n        offset += len\n      } else {\n        offset += buf.write(key + '=' + val, offset)\n      }\n\n      buf[oldOffset] = offset - oldOffset - 1\n    })\n\n    that.encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  that.decode = function (buf, offset, len) {\n    if (!offset) offset = 0\n    if (!Number.isFinite(len)) len = buf.length\n    var data = {}\n    var oldOffset = offset\n\n    while (offset < len) {\n      var b = decodeBlock(buf, offset)\n      var i = bindexOf(b, equalSign)\n      offset += decodeBlock.bytes\n\n      if (b.length === 0) continue // ignore: most likely a single zero byte\n      if (i === -1) data[b.toString().toLowerCase()] = true\n      else if (i === 0) continue // ignore: invalid key-length\n      else {\n        var key = b.slice(0, i).toString().toLowerCase()\n        if (key in data) continue // ignore: overwriting not allowed\n        data[key] = binary ? b.slice(i + 1) : b.slice(i + 1).toString()\n      }\n    }\n\n    that.decode.bytes = offset - oldOffset\n    return data\n  }\n\n  that.encodingLength = function (data) {\n    if (!data) return 1 // 1 byte (single empty byte)\n    var keys = Object.keys(data)\n    if (keys.length === 0) return 1 // 1 byte (single empty byte)\n    return keys.reduce(function (total, key) {\n      var val = data[key]\n      total += Buffer.byteLength(key) + 1 // +1 byte to store field length\n      if (Buffer.isBuffer(val)) total += val.length + 1 // +1 byte to fit equal sign\n      else if (val !== true) total += Buffer.byteLength(String(val)) + 1 // +1 byte to fit equal sign\n      return total\n    }, 0)\n  }\n\n  return that\n}\n\nfunction decodeBlock (buf, offset) {\n  var len = buf[offset]\n  var to = offset + 1 + len\n  var b = buf.slice(offset + 1, to > buf.length ? buf.length : to)\n  decodeBlock.bytes = len + 1\n  return b\n}\n"]},"metadata":{},"sourceType":"script"}