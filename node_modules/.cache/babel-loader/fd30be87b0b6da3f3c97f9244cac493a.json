{"ast":null,"code":"'use strict';\n/* eslint-disable\n  class-methods-use-this,\n  func-names\n*/\n\nconst sockjs = require('sockjs');\n\nconst BaseServer = require('./BaseServer'); // Workaround for sockjs@~0.3.19\n// sockjs will remove Origin header, however Origin header is required for checking host.\n// See https://github.com/webpack/webpack-dev-server/issues/1604 for more information\n\n\n{\n  const SockjsSession = require('sockjs/lib/transport').Session;\n\n  const decorateConnection = SockjsSession.prototype.decorateConnection;\n\n  SockjsSession.prototype.decorateConnection = function (req) {\n    decorateConnection.call(this, req);\n    const connection = this.connection;\n\n    if (connection.headers && !('origin' in connection.headers) && 'origin' in req.headers) {\n      connection.headers.origin = req.headers.origin;\n    }\n  };\n}\nmodule.exports = class SockJSServer extends BaseServer {\n  // options has: error (function), debug (function), server (http/s server), path (string)\n  constructor(server) {\n    super(server);\n    this.socket = sockjs.createServer({\n      // Use provided up-to-date sockjs-client\n      sockjs_url: '/__webpack_dev_server__/sockjs.bundle.js',\n      // Limit useless logs\n      log: (severity, line) => {\n        if (severity === 'error') {\n          this.server.log.error(line);\n        } else {\n          this.server.log.debug(line);\n        }\n      }\n    });\n    this.socket.installHandlers(this.server.listeningApp, {\n      prefix: this.server.sockPath\n    });\n  }\n\n  send(connection, message) {\n    // prevent cases where the server is trying to send data while connection is closing\n    if (connection.readyState !== 1) {\n      return;\n    }\n\n    connection.write(message);\n  }\n\n  close(connection) {\n    connection.close();\n  } // f should be passed the resulting connection and the connection headers\n\n\n  onConnection(f) {\n    this.socket.on('connection', connection => {\n      f(connection, connection ? connection.headers : null);\n    });\n  }\n\n  onConnectionClose(connection, f) {\n    connection.on('close', f);\n  }\n\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/webpack-dev-server/lib/servers/SockJSServer.js"],"names":["sockjs","require","BaseServer","SockjsSession","Session","decorateConnection","prototype","req","call","connection","headers","origin","module","exports","SockJSServer","constructor","server","socket","createServer","sockjs_url","log","severity","line","error","debug","installHandlers","listeningApp","prefix","sockPath","send","message","readyState","write","close","onConnection","f","on","onConnectionClose"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B,C,CAEA;AACA;AACA;;;AACA;AACE,QAAME,aAAa,GAAGF,OAAO,CAAC,sBAAD,CAAP,CAAgCG,OAAtD;;AACA,QAAMC,kBAAkB,GAAGF,aAAa,CAACG,SAAd,CAAwBD,kBAAnD;;AACAF,EAAAA,aAAa,CAACG,SAAd,CAAwBD,kBAAxB,GAA6C,UAASE,GAAT,EAAc;AACzDF,IAAAA,kBAAkB,CAACG,IAAnB,CAAwB,IAAxB,EAA8BD,GAA9B;AACA,UAAME,UAAU,GAAG,KAAKA,UAAxB;;AACA,QACEA,UAAU,CAACC,OAAX,IACA,EAAE,YAAYD,UAAU,CAACC,OAAzB,CADA,IAEA,YAAYH,GAAG,CAACG,OAHlB,EAIE;AACAD,MAAAA,UAAU,CAACC,OAAX,CAAmBC,MAAnB,GAA4BJ,GAAG,CAACG,OAAJ,CAAYC,MAAxC;AACD;AACF,GAVD;AAWD;AAEDC,MAAM,CAACC,OAAP,GAAiB,MAAMC,YAAN,SAA2BZ,UAA3B,CAAsC;AACrD;AACAa,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,UAAMA,MAAN;AACA,SAAKC,MAAL,GAAcjB,MAAM,CAACkB,YAAP,CAAoB;AAChC;AACAC,MAAAA,UAAU,EAAE,0CAFoB;AAGhC;AACAC,MAAAA,GAAG,EAAE,CAACC,QAAD,EAAWC,IAAX,KAAoB;AACvB,YAAID,QAAQ,KAAK,OAAjB,EAA0B;AACxB,eAAKL,MAAL,CAAYI,GAAZ,CAAgBG,KAAhB,CAAsBD,IAAtB;AACD,SAFD,MAEO;AACL,eAAKN,MAAL,CAAYI,GAAZ,CAAgBI,KAAhB,CAAsBF,IAAtB;AACD;AACF;AAV+B,KAApB,CAAd;AAaA,SAAKL,MAAL,CAAYQ,eAAZ,CAA4B,KAAKT,MAAL,CAAYU,YAAxC,EAAsD;AACpDC,MAAAA,MAAM,EAAE,KAAKX,MAAL,CAAYY;AADgC,KAAtD;AAGD;;AAEDC,EAAAA,IAAI,CAACpB,UAAD,EAAaqB,OAAb,EAAsB;AACxB;AACA,QAAIrB,UAAU,CAACsB,UAAX,KAA0B,CAA9B,EAAiC;AAC/B;AACD;;AAEDtB,IAAAA,UAAU,CAACuB,KAAX,CAAiBF,OAAjB;AACD;;AAEDG,EAAAA,KAAK,CAACxB,UAAD,EAAa;AAChBA,IAAAA,UAAU,CAACwB,KAAX;AACD,GAjCoD,CAmCrD;;;AACAC,EAAAA,YAAY,CAACC,CAAD,EAAI;AACd,SAAKlB,MAAL,CAAYmB,EAAZ,CAAe,YAAf,EAA8B3B,UAAD,IAAgB;AAC3C0B,MAAAA,CAAC,CAAC1B,UAAD,EAAaA,UAAU,GAAGA,UAAU,CAACC,OAAd,GAAwB,IAA/C,CAAD;AACD,KAFD;AAGD;;AAED2B,EAAAA,iBAAiB,CAAC5B,UAAD,EAAa0B,CAAb,EAAgB;AAC/B1B,IAAAA,UAAU,CAAC2B,EAAX,CAAc,OAAd,EAAuBD,CAAvB;AACD;;AA5CoD,CAAvD","sourcesContent":["'use strict';\n\n/* eslint-disable\n  class-methods-use-this,\n  func-names\n*/\nconst sockjs = require('sockjs');\nconst BaseServer = require('./BaseServer');\n\n// Workaround for sockjs@~0.3.19\n// sockjs will remove Origin header, however Origin header is required for checking host.\n// See https://github.com/webpack/webpack-dev-server/issues/1604 for more information\n{\n  const SockjsSession = require('sockjs/lib/transport').Session;\n  const decorateConnection = SockjsSession.prototype.decorateConnection;\n  SockjsSession.prototype.decorateConnection = function(req) {\n    decorateConnection.call(this, req);\n    const connection = this.connection;\n    if (\n      connection.headers &&\n      !('origin' in connection.headers) &&\n      'origin' in req.headers\n    ) {\n      connection.headers.origin = req.headers.origin;\n    }\n  };\n}\n\nmodule.exports = class SockJSServer extends BaseServer {\n  // options has: error (function), debug (function), server (http/s server), path (string)\n  constructor(server) {\n    super(server);\n    this.socket = sockjs.createServer({\n      // Use provided up-to-date sockjs-client\n      sockjs_url: '/__webpack_dev_server__/sockjs.bundle.js',\n      // Limit useless logs\n      log: (severity, line) => {\n        if (severity === 'error') {\n          this.server.log.error(line);\n        } else {\n          this.server.log.debug(line);\n        }\n      },\n    });\n\n    this.socket.installHandlers(this.server.listeningApp, {\n      prefix: this.server.sockPath,\n    });\n  }\n\n  send(connection, message) {\n    // prevent cases where the server is trying to send data while connection is closing\n    if (connection.readyState !== 1) {\n      return;\n    }\n\n    connection.write(message);\n  }\n\n  close(connection) {\n    connection.close();\n  }\n\n  // f should be passed the resulting connection and the connection headers\n  onConnection(f) {\n    this.socket.on('connection', (connection) => {\n      f(connection, connection ? connection.headers : null);\n    });\n  }\n\n  onConnectionClose(connection, f) {\n    connection.on('close', f);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}