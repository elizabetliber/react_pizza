{"ast":null,"code":"'use strict';\n/* eslint-disable\n  arrow-parens,\n  multiline-ternary,\n  consistent-return,\n  no-param-reassign,\n  prefer-destructuring\n*/\n\nconst noop = () => {};\n\nconst levels = Symbol('levels');\nconst instance = Symbol('instance');\n\nclass MethodFactory {\n  constructor(logger) {\n    this[levels] = {\n      TRACE: 0,\n      DEBUG: 1,\n      INFO: 2,\n      WARN: 3,\n      ERROR: 4,\n      SILENT: 5\n    };\n    this[instance] = logger;\n  }\n\n  set logger(logger) {\n    this[instance] = logger;\n  }\n\n  get logger() {\n    return this[instance];\n  }\n\n  get levels() {\n    return this[levels];\n  }\n\n  get methods() {\n    return Object.keys(this.levels).map(key => key.toLowerCase()).filter(key => key !== 'silent');\n  }\n\n  distillLevel(level) {\n    let result = level;\n\n    if (typeof result === 'string' && typeof this.levels[result.toUpperCase()] !== 'undefined') {\n      result = this.levels[result.toUpperCase()];\n    }\n\n    if (this.levelValid(result)) {\n      return result;\n    }\n  }\n\n  levelValid(level) {\n    if (typeof level === 'number' && level >= 0 && level <= this.levels.SILENT) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Build the best logging method possible for this env\n   * Wherever possible we want to bind, not wrap, to preserve stack traces.\n   * Since we're targeting modern browsers, there's no need to wait for the\n   * console to become available.\n   */\n  // eslint-disable-next-line class-methods-use-this\n\n\n  make(method) {\n    if (method === 'debug') {\n      method = 'log';\n    }\n    /* eslint-disable no-console */\n\n\n    if (typeof console[method] !== 'undefined') {\n      return this.bindMethod(console, method);\n    } else if (typeof console.log !== 'undefined') {\n      return this.bindMethod(console, 'log');\n    }\n    /* eslint-enable no-console */\n\n\n    return noop;\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  bindMethod(obj, name) {\n    const method = obj[name];\n\n    if (typeof method.bind === 'function') {\n      return method.bind(obj);\n    }\n\n    try {\n      return Function.prototype.bind.call(method, obj);\n    } catch (err) {\n      // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n      return function result() {\n        // eslint-disable-next-line prefer-rest-params\n        return Function.prototype.apply.apply(method, [obj, arguments]);\n      };\n    }\n  }\n\n  replaceMethods(logLevel) {\n    const level = this.distillLevel(logLevel);\n\n    if (level == null) {\n      throw new Error(`loglevel: replaceMethods() called with invalid level: ${logLevel}`);\n    }\n\n    if (!this.logger || this.logger.type !== 'LogLevel') {\n      throw new TypeError('loglevel: Logger is undefined or invalid. Please specify a valid Logger instance.');\n    }\n\n    this.methods.forEach(method => {\n      this.logger[method] = this.levels[method.toUpperCase()] < level ? noop : this.make(method);\n    }); // Define log.log as an alias for log.debug\n\n    this.logger.log = this.logger.debug;\n  }\n\n}\n\nmodule.exports = MethodFactory;","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/webpack-log/src/loglevel/MethodFactory.js"],"names":["noop","levels","Symbol","instance","MethodFactory","constructor","logger","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","methods","Object","keys","map","key","toLowerCase","filter","distillLevel","level","result","toUpperCase","levelValid","make","method","console","bindMethod","log","obj","name","bind","Function","prototype","call","err","apply","arguments","replaceMethods","logLevel","Error","type","TypeError","forEach","debug","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable\n  arrow-parens,\n  multiline-ternary,\n  consistent-return,\n  no-param-reassign,\n  prefer-destructuring\n*/\nconst noop = () => {};\n\nconst levels = Symbol('levels');\nconst instance = Symbol('instance');\n\nclass MethodFactory {\n  constructor(logger) {\n    this[levels] = {\n      TRACE: 0,\n      DEBUG: 1,\n      INFO: 2,\n      WARN: 3,\n      ERROR: 4,\n      SILENT: 5\n    };\n\n    this[instance] = logger;\n  }\n\n  set logger(logger) {\n    this[instance] = logger;\n  }\n\n  get logger() {\n    return this[instance];\n  }\n\n  get levels() {\n    return this[levels];\n  }\n\n  get methods() {\n    return Object.keys(this.levels)\n      .map((key) => key.toLowerCase())\n      .filter((key) => key !== 'silent');\n  }\n\n  distillLevel(level) {\n    let result = level;\n\n    if (\n      typeof result === 'string' &&\n      typeof this.levels[result.toUpperCase()] !== 'undefined'\n    ) {\n      result = this.levels[result.toUpperCase()];\n    }\n\n    if (this.levelValid(result)) {\n      return result;\n    }\n  }\n\n  levelValid(level) {\n    if (\n      typeof level === 'number' && level >= 0 &&\n      level <= this.levels.SILENT\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Build the best logging method possible for this env\n   * Wherever possible we want to bind, not wrap, to preserve stack traces.\n   * Since we're targeting modern browsers, there's no need to wait for the\n   * console to become available.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  make(method) {\n    if (method === 'debug') {\n      method = 'log';\n    }\n\n    /* eslint-disable no-console */\n    if (typeof console[method] !== 'undefined') {\n      return this.bindMethod(console, method);\n    } else if (typeof console.log !== 'undefined') {\n      return this.bindMethod(console, 'log');\n    }\n\n    /* eslint-enable no-console */\n    return noop;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  bindMethod(obj, name) {\n    const method = obj[name];\n\n    if (typeof method.bind === 'function') {\n      return method.bind(obj);\n    }\n\n    try {\n      return Function.prototype.bind.call(method, obj);\n    } catch (err) {\n      // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n      return function result() {\n        // eslint-disable-next-line prefer-rest-params\n        return Function.prototype.apply.apply(method, [obj, arguments]);\n      };\n    }\n  }\n\n  replaceMethods(logLevel) {\n    const level = this.distillLevel(logLevel);\n\n    if (level == null) {\n      throw new Error(\n        `loglevel: replaceMethods() called with invalid level: ${logLevel}`\n      );\n    }\n\n    if (!this.logger || this.logger.type !== 'LogLevel') {\n      throw new TypeError(\n        'loglevel: Logger is undefined or invalid. Please specify a valid Logger instance.'\n      );\n    }\n\n    this.methods.forEach((method) => {\n      this.logger[method] = (this.levels[method.toUpperCase()] < level)\n        ? noop\n        : this.make(method);\n    });\n\n    // Define log.log as an alias for log.debug\n    this.logger.log = this.logger.debug;\n  }\n}\n\nmodule.exports = MethodFactory;\n"]},"metadata":{},"sourceType":"script"}