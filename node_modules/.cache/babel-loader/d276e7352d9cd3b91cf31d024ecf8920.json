{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nfunction Hose(socket, options, filter) {\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    filter = options;\n    options = {};\n  }\n\n  this.socket = socket;\n  this.options = options;\n  this.filter = filter;\n  this.buffer = null;\n  var self = this;\n  this.listeners = {\n    error: function (err) {\n      return self.onError(err);\n    },\n    data: function (chunk) {\n      return self.onData(chunk);\n    },\n    end: function () {\n      return self.onEnd();\n    }\n  };\n  this.socket.on('error', this.listeners.error);\n  this.socket.on('data', this.listeners.data);\n  this.socket.on('end', this.listeners.end);\n}\n\nutil.inherits(Hose, EventEmitter);\nmodule.exports = Hose;\n\nHose.create = function create(socket, options, filter) {\n  return new Hose(socket, options, filter);\n};\n\nHose.prototype.detach = function detach() {\n  // Stop the flow\n  this.socket.pause();\n  this.socket.removeListener('error', this.listeners.error);\n  this.socket.removeListener('data', this.listeners.data);\n  this.socket.removeListener('end', this.listeners.end);\n};\n\nHose.prototype.reemit = function reemit() {\n  var buffer = this.buffer;\n  this.buffer = null; // Modern age\n\n  if (this.socket.unshift) {\n    this.socket.unshift(buffer);\n    if (this.socket.listeners('data').length > 0) this.socket.resume();\n    return;\n  } // Rusty node v0.8\n\n\n  if (this.socket.ondata) this.socket.ondata(buffer, 0, buffer.length);\n  this.socket.emit('data', buffer);\n  this.socket.resume();\n};\n\nHose.prototype.onError = function onError(err) {\n  this.detach();\n  this.emit('error', err);\n};\n\nHose.prototype.onData = function onData(chunk) {\n  if (this.buffer) this.buffer = Buffer.concat([this.buffer, chunk]);else this.buffer = chunk;\n  var self = this;\n  this.filter(this.buffer, function (err, protocol) {\n    if (err) return self.onError(err); // No protocol selected yet\n\n    if (!protocol) return;\n    self.detach();\n    self.emit('select', protocol, self.socket);\n    self.reemit();\n  });\n};\n\nHose.prototype.onEnd = function onEnd() {\n  this.detach();\n  this.emit('error', new Error('Not enough data to recognize protocol'));\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/select-hose/lib/hose.js"],"names":["util","require","EventEmitter","Hose","socket","options","filter","call","buffer","self","listeners","error","err","onError","data","chunk","onData","end","onEnd","on","inherits","module","exports","create","prototype","detach","pause","removeListener","reemit","unshift","length","resume","ondata","emit","Buffer","concat","protocol","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction Hose(socket, options, filter) {\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    filter = options;\n    options = {};\n  }\n\n  this.socket = socket;\n  this.options = options;\n  this.filter = filter;\n\n  this.buffer = null;\n\n  var self = this;\n  this.listeners = {\n    error: function(err) {\n      return self.onError(err);\n    },\n    data: function(chunk) {\n      return self.onData(chunk);\n    },\n    end: function() {\n      return self.onEnd();\n    }\n  };\n\n  this.socket.on('error', this.listeners.error);\n  this.socket.on('data', this.listeners.data);\n  this.socket.on('end', this.listeners.end);\n}\nutil.inherits(Hose, EventEmitter);\nmodule.exports = Hose;\n\nHose.create = function create(socket, options, filter) {\n  return new Hose(socket, options, filter);\n};\n\nHose.prototype.detach = function detach() {\n  // Stop the flow\n  this.socket.pause();\n\n  this.socket.removeListener('error', this.listeners.error);\n  this.socket.removeListener('data', this.listeners.data);\n  this.socket.removeListener('end', this.listeners.end);\n};\n\nHose.prototype.reemit = function reemit() {\n  var buffer = this.buffer;\n  this.buffer = null;\n\n  // Modern age\n  if (this.socket.unshift) {\n    this.socket.unshift(buffer);\n    if (this.socket.listeners('data').length > 0)\n      this.socket.resume();\n    return;\n  }\n\n  // Rusty node v0.8\n  if (this.socket.ondata)\n    this.socket.ondata(buffer, 0, buffer.length);\n  this.socket.emit('data', buffer);\n  this.socket.resume();\n};\n\nHose.prototype.onError = function onError(err) {\n  this.detach();\n  this.emit('error', err);\n};\n\nHose.prototype.onData = function onData(chunk) {\n  if (this.buffer)\n    this.buffer = Buffer.concat([ this.buffer, chunk ]);\n  else\n    this.buffer = chunk;\n\n  var self = this;\n  this.filter(this.buffer, function(err, protocol) {\n    if (err)\n      return self.onError(err);\n\n    // No protocol selected yet\n    if (!protocol)\n      return;\n\n    self.detach();\n    self.emit('select', protocol, self.socket);\n    self.reemit();\n  });\n};\n\nHose.prototype.onEnd = function onEnd() {\n  this.detach();\n  this.emit('error', new Error('Not enough data to recognize protocol'));\n};\n"]},"metadata":{},"sourceType":"script"}