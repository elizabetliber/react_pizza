{"ast":null,"code":"/*jshint node:true */\nvar assert = require('assert');\n\nexports.HTTPParser = HTTPParser;\n\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n\n  if (type === undefined) {// Node v12+\n  } else {\n    this.initialize(type);\n  }\n}\n\nHTTPParser.prototype.initialize = function (type, async_resource) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n};\n\nHTTPParser.encoding = 'ascii';\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\n\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE'; // Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\n\nvar kOnHeaders = HTTPParser.kOnHeaders = 1;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\nvar kOnBody = HTTPParser.kOnBody = 3;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 4; // Some handler stubs, needed for compatibility\n\nHTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function () {};\n\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n  get: function () {\n    // hack for backward compatibility\n    compatMode0_12 = false;\n    return 99;\n  }\n});\nvar methods = exports.methods = HTTPParser.methods = ['DELETE', 'GET', 'HEAD', 'POST', 'PUT', 'CONNECT', 'OPTIONS', 'TRACE', 'COPY', 'LOCK', 'MKCOL', 'MOVE', 'PROPFIND', 'PROPPATCH', 'SEARCH', 'UNLOCK', 'BIND', 'REBIND', 'UNBIND', 'ACL', 'REPORT', 'MKACTIVITY', 'CHECKOUT', 'MERGE', 'M-SEARCH', 'NOTIFY', 'SUBSCRIBE', 'UNSUBSCRIBE', 'PATCH', 'PURGE', 'MKCALENDAR', 'LINK', 'UNLINK'];\nvar method_connect = methods.indexOf('CONNECT');\nHTTPParser.prototype.reinitialize = HTTPParser;\n\nHTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function () {};\n\nHTTPParser.prototype._compatMode0_11 = false;\n\nHTTPParser.prototype.getAsyncId = function () {\n  return 0;\n};\n\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\n\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  } // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n\n\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n\n    this.hadError = true;\n    return err;\n  }\n\n  this.chunk = null;\n  length = this.offset - start;\n\n  if (headerState[this.state]) {\n    this.headerSize += length;\n\n    if (this.headerSize > HTTPParser.maxHeaderSize) {\n      return new Error('max header size exceeded');\n    }\n  }\n\n  return length;\n};\n\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\n\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n}; // These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\n\n\nHTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function () {}; //For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\n\n\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\n\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\n\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n      chunk = this.chunk;\n\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) {\n      // \\n\n      var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  } //line split over multiple chunks\n\n\n  this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n  this.offset = this.end;\n};\n\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\n\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n\n  if (k) {\n    // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\n\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\n\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n\n  if (!line) {\n    return;\n  }\n\n  var match = requestExp.exec(line);\n\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\n\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n\n  if (!line) {\n    return;\n  }\n\n  var match = responseExp.exec(line);\n\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4]; // Implied zero length.\n\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n\n  this.state = 'HEADER';\n};\n\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n\n  if (this.body_bytes !== null || this.isChunked) {\n    // || skipBody\n    return true;\n  }\n\n  return false;\n};\n\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  var info = this.info;\n\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n    var hasUpgradeHeader = false;\n\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n\n          break;\n\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n\n        case 'upgrade':\n          hasUpgradeHeader = true;\n          break;\n      }\n    } // if both isChunked and hasContentLength, isChunked wins\n    // This is required so the body is parsed using the chunked method, and matches\n    // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n    // encoding into the body), and/or disable shouldKeepAlive to be more\n    // resilient.\n\n\n    if (this.isChunked && hasContentLength) {\n      hasContentLength = false;\n      this.body_bytes = null;\n    } // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n    // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n    //   mandatory only when it is a 101 Switching Protocols response,\n    //   otherwise it is purely informational, to announce support.\n\n\n    if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {\n      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n    } else {\n      info.upgrade = info.method === method_connect;\n    }\n\n    if (this.isChunked && info.upgrade) {\n      this.isChunked = false;\n    }\n\n    info.shouldKeepAlive = this.shouldKeepAlive(); //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n\n    var skipBody;\n\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n\n    if (skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest(); // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n      //   need this \"return true;\" if it's an upgrade request.\n\n      return info.upgrade;\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  this.body_bytes = parseInt(line, 16);\n\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\n\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n\n    this.nextRequest();\n  }\n};\n\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\n\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n}; // backward compat to node < 0.11.6\n\n\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function () {\n      return this[k];\n    },\n    set: function (to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      method_connect = 'CONNECT';\n      return this[k] = to;\n    }\n  });\n});\n\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/http-parser-js/http-parser.js"],"names":["assert","require","exports","HTTPParser","type","ok","REQUEST","RESPONSE","undefined","initialize","prototype","async_resource","state","info","headers","upgrade","trailers","line","isChunked","connection","headerSize","body_bytes","isUserCall","hadError","encoding","maxHeaderSize","kOnHeaders","kOnHeadersComplete","kOnBody","kOnMessageComplete","compatMode0_12","Object","defineProperty","get","methods","method_connect","indexOf","reinitialize","close","pause","resume","free","_compatMode0_11","getAsyncId","headerState","REQUEST_LINE","RESPONSE_LINE","HEADER","execute","chunk","start","length","TypeError","offset","end","err","Error","stateFinishAllowed","BODY_RAW","finish","userCall","consume","unconsume","getCurrentBuffer","self","ret","nextRequest","consumeLine","i","toString","charAt","substr","headerExp","headerContinueExp","parseHeader","parseErrorCode","match","exec","k","push","matchContinue","requestExp","method","url","versionMajor","versionMinor","responseExp","statusCode","statusMessage","shouldKeepAlive","hasContentLength","currentContentLengthValue","hasUpgradeHeader","toLowerCase","skipBody","BODY_CHUNKHEAD","parseInt","BODY_CHUNK","Math","min","BODY_CHUNKEMPTYLINE","equal","BODY_CHUNKTRAILERS","BODY_SIZED","forEach","name","set","to","code"],"mappings":"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","sourcesContent":["/*jshint node:true */\n\nvar assert = require('assert');\n\nexports.HTTPParser = HTTPParser;\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n  if (type === undefined) {\n    // Node v12+\n  } else {\n    this.initialize(type);\n  }\n}\nHTTPParser.prototype.initialize = function (type, async_resource) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n};\n\nHTTPParser.encoding = 'ascii';\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE';\n\n// Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\nvar kOnHeaders = HTTPParser.kOnHeaders = 1;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\nvar kOnBody = HTTPParser.kOnBody = 3;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;\n\n// Some handler stubs, needed for compatibility\nHTTPParser.prototype[kOnHeaders] =\nHTTPParser.prototype[kOnHeadersComplete] =\nHTTPParser.prototype[kOnBody] =\nHTTPParser.prototype[kOnMessageComplete] = function () {};\n\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n    get: function () {\n      // hack for backward compatibility\n      compatMode0_12 = false;\n      return 99;\n    }\n  });\n\nvar methods = exports.methods = HTTPParser.methods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'COPY',\n  'LOCK',\n  'MKCOL',\n  'MOVE',\n  'PROPFIND',\n  'PROPPATCH',\n  'SEARCH',\n  'UNLOCK',\n  'BIND',\n  'REBIND',\n  'UNBIND',\n  'ACL',\n  'REPORT',\n  'MKACTIVITY',\n  'CHECKOUT',\n  'MERGE',\n  'M-SEARCH',\n  'NOTIFY',\n  'SUBSCRIBE',\n  'UNSUBSCRIBE',\n  'PATCH',\n  'PURGE',\n  'MKCALENDAR',\n  'LINK',\n  'UNLINK'\n];\nvar method_connect = methods.indexOf('CONNECT');\nHTTPParser.prototype.reinitialize = HTTPParser;\nHTTPParser.prototype.close =\nHTTPParser.prototype.pause =\nHTTPParser.prototype.resume =\nHTTPParser.prototype.free = function () {};\nHTTPParser.prototype._compatMode0_11 = false;\nHTTPParser.prototype.getAsyncId = function() { return 0; };\n\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  }\n\n  // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n    this.hadError = true;\n    return err;\n  }\n  this.chunk = null;\n  length = this.offset - start;\n  if (headerState[this.state]) {\n    this.headerSize += length;\n    if (this.headerSize > HTTPParser.maxHeaderSize) {\n      return new Error('max header size exceeded');\n    }\n  }\n  return length;\n};\n\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n};\n\n// These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\nHTTPParser.prototype.consume =\nHTTPParser.prototype.unconsume =\nHTTPParser.prototype.getCurrentBuffer = function () {};\n\n//For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\n\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\n\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n      chunk = this.chunk;\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) { // \\n\n      var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  }\n  //line split over multiple chunks\n  this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n  this.offset = this.end;\n};\n\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n  if (k) { // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\n\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = requestExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\n\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = responseExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4];\n  // Implied zero length.\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n  this.state = 'HEADER';\n};\n\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n  if (this.body_bytes !== null || this.isChunked) { // || skipBody\n    return true;\n  }\n  return false;\n};\n\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  var info = this.info;\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n    var hasUpgradeHeader = false;\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n          break;\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n        case 'upgrade':\n          hasUpgradeHeader = true;\n          break;\n      }\n    }\n\n    // if both isChunked and hasContentLength, isChunked wins\n    // This is required so the body is parsed using the chunked method, and matches\n    // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n    // encoding into the body), and/or disable shouldKeepAlive to be more\n    // resilient.\n    if (this.isChunked && hasContentLength) {\n      hasContentLength = false;\n      this.body_bytes = null;\n    }\n\n    // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n    // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n    //   mandatory only when it is a 101 Switching Protocols response,\n    //   otherwise it is purely informational, to announce support.\n    if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {\n      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n    } else {\n      info.upgrade = info.method === method_connect;\n    }\n\n    if (this.isChunked && info.upgrade) {\n      this.isChunked = false;\n    }\n\n    info.shouldKeepAlive = this.shouldKeepAlive();\n    //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n    var skipBody;\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor,\n          info.versionMinor, info.headers, info.method, info.url, info.statusCode,\n          info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n    if (skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest();\n      // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n      //   need this \"return true;\" if it's an upgrade request.\n      return info.upgrade;\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  this.body_bytes = parseInt(line, 16);\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\n\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n    this.nextRequest();\n  }\n};\n\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\n\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n};\n\n// backward compat to node < 0.11.6\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function () {\n      return this[k];\n    },\n    set: function (to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      method_connect = 'CONNECT';\n      return (this[k] = to);\n    }\n  });\n});\n\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}\n"]},"metadata":{},"sourceType":"script"}