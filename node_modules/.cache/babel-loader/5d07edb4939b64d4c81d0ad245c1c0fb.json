{"ast":null,"code":"'use strict';\n/* eslint-disable\n  class-methods-use-this\n*/\n\nconst ws = require('ws');\n\nconst BaseServer = require('./BaseServer');\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  constructor(server) {\n    super(server);\n    this.wsServer = new ws.Server({\n      noServer: true,\n      path: this.server.sockPath\n    });\n    this.server.listeningApp.on('upgrade', (req, sock, head) => {\n      if (!this.wsServer.shouldHandle(req)) {\n        return;\n      }\n\n      this.wsServer.handleUpgrade(req, sock, head, connection => {\n        this.wsServer.emit('connection', connection, req);\n      });\n    });\n    this.wsServer.on('error', err => {\n      this.server.log.error(err.message);\n    });\n\n    const noop = () => {};\n\n    setInterval(() => {\n      this.wsServer.clients.forEach(socket => {\n        if (socket.isAlive === false) {\n          return socket.terminate();\n        }\n\n        socket.isAlive = false;\n        socket.ping(noop);\n      });\n    }, this.server.heartbeatInterval);\n  }\n\n  send(connection, message) {\n    // prevent cases where the server is trying to send data while connection is closing\n    if (connection.readyState !== 1) {\n      return;\n    }\n\n    connection.send(message);\n  }\n\n  close(connection) {\n    connection.close();\n  } // f should be passed the resulting connection and the connection headers\n\n\n  onConnection(f) {\n    this.wsServer.on('connection', (connection, req) => {\n      connection.isAlive = true;\n      connection.on('pong', () => {\n        connection.isAlive = true;\n      });\n      f(connection, req.headers);\n    });\n  }\n\n  onConnectionClose(connection, f) {\n    connection.on('close', f);\n  }\n\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/webpack-dev-server/lib/servers/WebsocketServer.js"],"names":["ws","require","BaseServer","module","exports","WebsocketServer","constructor","server","wsServer","Server","noServer","path","sockPath","listeningApp","on","req","sock","head","shouldHandle","handleUpgrade","connection","emit","err","log","error","message","noop","setInterval","clients","forEach","socket","isAlive","terminate","ping","heartbeatInterval","send","readyState","close","onConnection","f","headers","onConnectionClose"],"mappings":"AAAA;AAEA;AACA;AACA;;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AAEAE,MAAM,CAACC,OAAP,GAAiB,MAAMC,eAAN,SAA8BH,UAA9B,CAAyC;AACxDI,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,UAAMA,MAAN;AACA,SAAKC,QAAL,GAAgB,IAAIR,EAAE,CAACS,MAAP,CAAc;AAC5BC,MAAAA,QAAQ,EAAE,IADkB;AAE5BC,MAAAA,IAAI,EAAE,KAAKJ,MAAL,CAAYK;AAFU,KAAd,CAAhB;AAKA,SAAKL,MAAL,CAAYM,YAAZ,CAAyBC,EAAzB,CAA4B,SAA5B,EAAuC,CAACC,GAAD,EAAMC,IAAN,EAAYC,IAAZ,KAAqB;AAC1D,UAAI,CAAC,KAAKT,QAAL,CAAcU,YAAd,CAA2BH,GAA3B,CAAL,EAAsC;AACpC;AACD;;AAED,WAAKP,QAAL,CAAcW,aAAd,CAA4BJ,GAA5B,EAAiCC,IAAjC,EAAuCC,IAAvC,EAA8CG,UAAD,IAAgB;AAC3D,aAAKZ,QAAL,CAAca,IAAd,CAAmB,YAAnB,EAAiCD,UAAjC,EAA6CL,GAA7C;AACD,OAFD;AAGD,KARD;AAUA,SAAKP,QAAL,CAAcM,EAAd,CAAiB,OAAjB,EAA2BQ,GAAD,IAAS;AACjC,WAAKf,MAAL,CAAYgB,GAAZ,CAAgBC,KAAhB,CAAsBF,GAAG,CAACG,OAA1B;AACD,KAFD;;AAIA,UAAMC,IAAI,GAAG,MAAM,CAAE,CAArB;;AAEAC,IAAAA,WAAW,CAAC,MAAM;AAChB,WAAKnB,QAAL,CAAcoB,OAAd,CAAsBC,OAAtB,CAA+BC,MAAD,IAAY;AACxC,YAAIA,MAAM,CAACC,OAAP,KAAmB,KAAvB,EAA8B;AAC5B,iBAAOD,MAAM,CAACE,SAAP,EAAP;AACD;;AAEDF,QAAAA,MAAM,CAACC,OAAP,GAAiB,KAAjB;AACAD,QAAAA,MAAM,CAACG,IAAP,CAAYP,IAAZ;AACD,OAPD;AAQD,KATU,EASR,KAAKnB,MAAL,CAAY2B,iBATJ,CAAX;AAUD;;AAEDC,EAAAA,IAAI,CAACf,UAAD,EAAaK,OAAb,EAAsB;AACxB;AACA,QAAIL,UAAU,CAACgB,UAAX,KAA0B,CAA9B,EAAiC;AAC/B;AACD;;AAEDhB,IAAAA,UAAU,CAACe,IAAX,CAAgBV,OAAhB;AACD;;AAEDY,EAAAA,KAAK,CAACjB,UAAD,EAAa;AAChBA,IAAAA,UAAU,CAACiB,KAAX;AACD,GA/CuD,CAiDxD;;;AACAC,EAAAA,YAAY,CAACC,CAAD,EAAI;AACd,SAAK/B,QAAL,CAAcM,EAAd,CAAiB,YAAjB,EAA+B,CAACM,UAAD,EAAaL,GAAb,KAAqB;AAClDK,MAAAA,UAAU,CAACW,OAAX,GAAqB,IAArB;AACAX,MAAAA,UAAU,CAACN,EAAX,CAAc,MAAd,EAAsB,MAAM;AAC1BM,QAAAA,UAAU,CAACW,OAAX,GAAqB,IAArB;AACD,OAFD;AAGAQ,MAAAA,CAAC,CAACnB,UAAD,EAAaL,GAAG,CAACyB,OAAjB,CAAD;AACD,KAND;AAOD;;AAEDC,EAAAA,iBAAiB,CAACrB,UAAD,EAAamB,CAAb,EAAgB;AAC/BnB,IAAAA,UAAU,CAACN,EAAX,CAAc,OAAd,EAAuByB,CAAvB;AACD;;AA9DuD,CAA1D","sourcesContent":["'use strict';\n\n/* eslint-disable\n  class-methods-use-this\n*/\nconst ws = require('ws');\nconst BaseServer = require('./BaseServer');\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  constructor(server) {\n    super(server);\n    this.wsServer = new ws.Server({\n      noServer: true,\n      path: this.server.sockPath,\n    });\n\n    this.server.listeningApp.on('upgrade', (req, sock, head) => {\n      if (!this.wsServer.shouldHandle(req)) {\n        return;\n      }\n\n      this.wsServer.handleUpgrade(req, sock, head, (connection) => {\n        this.wsServer.emit('connection', connection, req);\n      });\n    });\n\n    this.wsServer.on('error', (err) => {\n      this.server.log.error(err.message);\n    });\n\n    const noop = () => {};\n\n    setInterval(() => {\n      this.wsServer.clients.forEach((socket) => {\n        if (socket.isAlive === false) {\n          return socket.terminate();\n        }\n\n        socket.isAlive = false;\n        socket.ping(noop);\n      });\n    }, this.server.heartbeatInterval);\n  }\n\n  send(connection, message) {\n    // prevent cases where the server is trying to send data while connection is closing\n    if (connection.readyState !== 1) {\n      return;\n    }\n\n    connection.send(message);\n  }\n\n  close(connection) {\n    connection.close();\n  }\n\n  // f should be passed the resulting connection and the connection headers\n  onConnection(f) {\n    this.wsServer.on('connection', (connection, req) => {\n      connection.isAlive = true;\n      connection.on('pong', () => {\n        connection.isAlive = true;\n      });\n      f(connection, req.headers);\n    });\n  }\n\n  onConnectionClose(connection, f) {\n    connection.on('close', f);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}