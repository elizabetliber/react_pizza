{"ast":null,"code":"'use strict';\n\nvar transport = require('../spdy-transport');\n\nvar assert = require('assert');\n\nvar util = require('util');\n\nvar debug = {\n  client: require('debug')('spdy:stream:client'),\n  server: require('debug')('spdy:stream:server')\n};\n\nvar Duplex = require('readable-stream').Duplex;\n\nfunction Stream(connection, options) {\n  Duplex.call(this);\n  var connectionState = connection._spdyState;\n  var state = {};\n  this._spdyState = state;\n  this.id = options.id;\n  this.method = options.method;\n  this.path = options.path;\n  this.host = options.host;\n  this.headers = options.headers || {};\n  this.connection = connection;\n  this.parent = options.parent || null;\n  state.socket = null;\n  state.protocol = connectionState.protocol;\n  state.constants = state.protocol.constants; // See _initPriority()\n\n  state.priority = null;\n  state.version = this.connection.getVersion();\n  state.isServer = this.connection.isServer();\n  state.debug = state.isServer ? debug.server : debug.client;\n  state.framer = connectionState.framer;\n  state.parser = connectionState.parser;\n  state.request = options.request;\n  state.needResponse = options.request;\n  state.window = connectionState.streamWindow.clone(options.id);\n  state.sessionWindow = connectionState.window;\n  state.maxChunk = connectionState.maxChunk; // Can't send incoming request\n  // (See `.send()` method)\n\n  state.sent = !state.request;\n  state.readable = options.readable !== false;\n  state.writable = options.writable !== false;\n  state.aborted = false;\n  state.corked = 0;\n  state.corkQueue = [];\n  state.timeout = new transport.utils.Timeout(this);\n  this.on('finish', this._onFinish);\n  this.on('end', this._onEnd);\n  var self = this;\n\n  function _onWindowOverflow() {\n    self._onWindowOverflow();\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow);\n  state.window.send.on('overflow', _onWindowOverflow);\n\n  this._initPriority(options.priority);\n\n  if (!state.readable) {\n    this.push(null);\n  }\n\n  if (!state.writable) {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  }\n}\n\nutil.inherits(Stream, Duplex);\nexports.Stream = Stream;\n\nStream.prototype._init = function _init(socket) {\n  this.socket = socket;\n};\n\nStream.prototype._initPriority = function _initPriority(priority) {\n  var state = this._spdyState;\n  var connectionState = this.connection._spdyState;\n  var root = connectionState.priorityRoot;\n\n  if (!priority) {\n    state.priority = root.addDefault(this.id);\n    return;\n  }\n\n  state.priority = root.add({\n    id: this.id,\n    parent: priority.parent,\n    weight: priority.weight,\n    exclusive: priority.exclusive\n  });\n};\n\nStream.prototype._handleFrame = function _handleFrame(frame) {\n  var state = this._spdyState; // Ignore any kind of data after abort\n\n  if (state.aborted) {\n    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type);\n    return;\n  } // Restart the timer on incoming frames\n\n\n  state.timeout.reset();\n\n  if (frame.type === 'DATA') {\n    this._handleData(frame);\n  } else if (frame.type === 'HEADERS') {\n    this._handleHeaders(frame);\n  } else if (frame.type === 'RST') {\n    this._handleRST(frame);\n  } else if (frame.type === 'WINDOW_UPDATE') {\n    this._handleWindowUpdate(frame);\n  } else if (frame.type === 'PRIORITY') {\n    this._handlePriority(frame);\n  } else if (frame.type === 'PUSH_PROMISE') {\n    this._handlePushPromise(frame);\n  }\n\n  if (frame.fin) {\n    state.debug('id=%d end', this.id);\n    this.push(null);\n  }\n};\n\nfunction checkAborted(stream, state, callback) {\n  if (state.aborted) {\n    state.debug('id=%d abort write', stream.id);\n    process.nextTick(function () {\n      callback(new Error('Stream write aborted'));\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction _send(stream, state, data, callback) {\n  if (checkAborted(stream, state, callback)) {\n    return;\n  }\n\n  state.debug('id=%d presend=%d', stream.id, data.length);\n  state.timeout.reset();\n  state.window.send.update(-data.length, function () {\n    if (checkAborted(stream, state, callback)) {\n      return;\n    }\n\n    state.debug('id=%d send=%d', stream.id, data.length);\n    state.timeout.reset();\n    state.framer.dataFrame({\n      id: stream.id,\n      priority: state.priority.getPriority(),\n      fin: false,\n      data: data\n    }, function (err) {\n      state.debug('id=%d postsend=%d', stream.id, data.length);\n      callback(err);\n    });\n  });\n}\n\nStream.prototype._write = function _write(data, enc, callback) {\n  var state = this._spdyState; // Send the request if it wasn't sent\n\n  if (!state.sent) {\n    this.send();\n  } // Writes should come after pending control frames (response and headers)\n\n\n  if (state.corked !== 0) {\n    var self = this;\n    state.corkQueue.push(function () {\n      self._write(data, enc, callback);\n    });\n    return;\n  } // Split DATA in chunks to prevent window from going negative\n\n\n  this._splitStart(data, _send, callback);\n};\n\nStream.prototype._splitStart = function _splitStart(data, onChunk, callback) {\n  return this._split(data, 0, onChunk, callback);\n};\n\nStream.prototype._split = function _split(data, offset, onChunk, callback) {\n  if (offset === data.length) {\n    return process.nextTick(callback);\n  }\n\n  var state = this._spdyState;\n  var local = state.window.send;\n  var session = state.sessionWindow.send;\n  var availSession = Math.max(0, session.getCurrent());\n\n  if (availSession === 0) {\n    availSession = session.getMax();\n  }\n\n  var availLocal = Math.max(0, local.getCurrent());\n\n  if (availLocal === 0) {\n    availLocal = local.getMax();\n  }\n\n  var avail = Math.min(availSession, availLocal);\n  avail = Math.min(avail, state.maxChunk);\n  var self = this;\n\n  if (avail === 0) {\n    state.window.send.update(0, function () {\n      self._split(data, offset, onChunk, callback);\n    });\n    return;\n  } // Split data in chunks in a following way:\n\n\n  var limit = avail;\n  var size = Math.min(data.length - offset, limit);\n  var chunk = data.slice(offset, offset + size);\n  onChunk(this, state, chunk, function (err) {\n    if (err) {\n      return callback(err);\n    } // Get the next chunk\n\n\n    self._split(data, offset + size, onChunk, callback);\n  });\n};\n\nStream.prototype._read = function _read() {\n  var state = this._spdyState;\n\n  if (!state.window.recv.isDraining()) {\n    return;\n  }\n\n  var delta = state.window.recv.getDelta();\n  state.debug('id=%d window emptying, update by %d', this.id, delta);\n  state.window.recv.update(delta);\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n};\n\nStream.prototype._handleData = function _handleData(frame) {\n  var state = this._spdyState; // DATA on ended or not readable stream!\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'STREAM_CLOSED'\n    });\n    return;\n  }\n\n  state.debug('id=%d recv=%d', this.id, frame.data.length);\n  state.window.recv.update(-frame.data.length);\n  this.push(frame.data);\n};\n\nStream.prototype._handleRST = function _handleRST(frame) {\n  if (frame.code !== 'CANCEL') {\n    this.emit('error', new Error('Got RST: ' + frame.code));\n  }\n\n  this.abort();\n};\n\nStream.prototype._handleWindowUpdate = function _handleWindowUpdate(frame) {\n  var state = this._spdyState;\n  state.window.send.update(frame.delta);\n};\n\nStream.prototype._onWindowOverflow = function _onWindowOverflow() {\n  var state = this._spdyState;\n  state.debug('id=%d window overflow', this.id);\n  state.framer.rstFrame({\n    id: this.id,\n    code: 'FLOW_CONTROL_ERROR'\n  });\n  this.aborted = true;\n  this.emit('error', new Error('HTTP2 window overflow'));\n};\n\nStream.prototype._handlePriority = function _handlePriority(frame) {\n  var state = this._spdyState;\n  state.priority.remove();\n  state.priority = null;\n\n  this._initPriority(frame.priority); // Mostly for testing purposes\n\n\n  this.emit('priority', frame.priority);\n};\n\nStream.prototype._handleHeaders = function _handleHeaders(frame) {\n  var state = this._spdyState;\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'STREAM_CLOSED'\n    });\n    return;\n  }\n\n  if (state.needResponse) {\n    return this._handleResponse(frame);\n  }\n\n  this.emit('headers', frame.headers);\n};\n\nStream.prototype._handleResponse = function _handleResponse(frame) {\n  var state = this._spdyState;\n\n  if (frame.headers[':status'] === undefined) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'PROTOCOL_ERROR'\n    });\n    return;\n  }\n\n  state.needResponse = false;\n  this.emit('response', frame.headers[':status'] | 0, frame.headers);\n};\n\nStream.prototype._onFinish = function _onFinish() {\n  var state = this._spdyState; // Send the request if it wasn't sent\n\n  if (!state.sent) {\n    // NOTE: will send HEADERS with FIN flag\n    this.send();\n  } else {\n    // Just an `.end()` without any writes will trigger immediate `finish` event\n    // without any calls to `_write()`.\n    if (state.corked !== 0) {\n      var self = this;\n      state.corkQueue.push(function () {\n        self._onFinish();\n      });\n      return;\n    }\n\n    state.framer.dataFrame({\n      id: this.id,\n      priority: state.priority.getPriority(),\n      fin: true,\n      data: Buffer.alloc(0)\n    });\n  }\n\n  this._maybeClose();\n};\n\nStream.prototype._onEnd = function _onEnd() {\n  this._maybeClose();\n};\n\nStream.prototype._checkEnded = function _checkEnded(callback) {\n  var state = this._spdyState;\n  var ended = false;\n\n  if (state.aborted) {\n    ended = true;\n  }\n\n  if (!state.writable || this._writableState.finished) {\n    ended = true;\n  }\n\n  if (!ended) {\n    return true;\n  }\n\n  if (!callback) {\n    return false;\n  }\n\n  var err = new Error('Ended stream can\\'t send frames');\n  process.nextTick(function () {\n    callback(err);\n  });\n  return false;\n};\n\nStream.prototype._maybeClose = function _maybeClose() {\n  var state = this._spdyState; // .abort() emits `close`\n\n  if (state.aborted) {\n    return;\n  }\n\n  if ((!state.readable || this._readableState.ended) && this._writableState.finished) {\n    // Clear timeout\n    state.timeout.set(0);\n    this.emit('close');\n  }\n};\n\nStream.prototype._handlePushPromise = function _handlePushPromise(frame) {\n  var push = this.connection._createStream({\n    id: frame.promisedId,\n    parent: this,\n    push: true,\n    request: true,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: false\n  }); // GOAWAY\n\n\n  if (this.connection._isGoaway(push.id)) {\n    return;\n  }\n\n  if (!this.emit('pushPromise', push)) {\n    push.abort();\n  }\n};\n\nStream.prototype._hardCork = function _hardCork() {\n  var state = this._spdyState;\n  this.cork();\n  state.corked++;\n};\n\nStream.prototype._hardUncork = function _hardUncork() {\n  var state = this._spdyState;\n  this.uncork();\n  state.corked--;\n\n  if (state.corked !== 0) {\n    return;\n  } // Invoke callbacks\n\n\n  var queue = state.corkQueue;\n  state.corkQueue = [];\n\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n};\n\nStream.prototype._sendPush = function _sendPush(status, response, callback) {\n  var self = this;\n  var state = this._spdyState;\n\n  this._hardCork();\n\n  state.framer.pushFrame({\n    id: this.parent.id,\n    promisedId: this.id,\n    priority: state.priority.toJSON(),\n    path: this.path,\n    host: this.host,\n    method: this.method,\n    status: status,\n    headers: this.headers,\n    response: response\n  }, function (err) {\n    self._hardUncork();\n\n    callback(err);\n  });\n};\n\nStream.prototype._wasSent = function _wasSent() {\n  var state = this._spdyState;\n  return state.sent;\n}; // Public API\n\n\nStream.prototype.send = function send(callback) {\n  var state = this._spdyState;\n\n  if (state.sent) {\n    var err = new Error('Stream was already sent');\n    process.nextTick(function () {\n      if (callback) {\n        callback(err);\n      }\n    });\n    return;\n  }\n\n  state.sent = true;\n  state.timeout.reset(); // GET requests should always be auto-finished\n\n  if (this.method === 'GET') {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  } // TODO(indunty): ideally it should just take a stream object as an input\n\n\n  var self = this;\n\n  this._hardCork();\n\n  state.framer.requestFrame({\n    id: this.id,\n    method: this.method,\n    path: this.path,\n    host: this.host,\n    priority: state.priority.toJSON(),\n    headers: this.headers,\n    fin: this._writableState.finished\n  }, function (err) {\n    self._hardUncork();\n\n    if (!callback) {\n      return;\n    }\n\n    callback(err);\n  });\n};\n\nStream.prototype.respond = function respond(status, headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n  assert(!state.request, 'Can\\'t respond on request');\n  state.timeout.reset();\n\n  if (!this._checkEnded(callback)) {\n    return;\n  }\n\n  var frame = {\n    id: this.id,\n    status: status,\n    headers: headers\n  };\n\n  this._hardCork();\n\n  state.framer.responseFrame(frame, function (err) {\n    self._hardUncork();\n\n    if (callback) {\n      callback(err);\n    }\n  });\n};\n\nStream.prototype.setWindow = function setWindow(size) {\n  var state = this._spdyState;\n  state.timeout.reset();\n\n  if (!this._checkEnded()) {\n    return;\n  }\n\n  state.debug('id=%d force window max=%d', this.id, size);\n  state.window.recv.setMax(size);\n  var delta = state.window.recv.getDelta();\n\n  if (delta === 0) {\n    return;\n  }\n\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n  state.window.recv.update(delta);\n};\n\nStream.prototype.sendHeaders = function sendHeaders(headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n  state.timeout.reset();\n\n  if (!this._checkEnded(callback)) {\n    return;\n  } // Request wasn't yet send, coalesce headers\n\n\n  if (!state.sent) {\n    this.headers = Object.assign({}, this.headers);\n    Object.assign(this.headers, headers);\n    process.nextTick(function () {\n      if (callback) {\n        callback(null);\n      }\n    });\n    return;\n  }\n\n  this._hardCork();\n\n  state.framer.headersFrame({\n    id: this.id,\n    headers: headers\n  }, function (err) {\n    self._hardUncork();\n\n    if (callback) {\n      callback(err);\n    }\n  });\n};\n\nStream.prototype._destroy = function destroy() {\n  this.abort();\n};\n\nStream.prototype.abort = function abort(code, callback) {\n  var state = this._spdyState; // .abort(callback)\n\n  if (typeof code === 'function') {\n    callback = code;\n    code = null;\n  }\n\n  if (this._readableState.ended && this._writableState.finished) {\n    state.debug('id=%d already closed', this.id);\n\n    if (callback) {\n      process.nextTick(callback);\n    }\n\n    return;\n  }\n\n  if (state.aborted) {\n    state.debug('id=%d already aborted', this.id);\n\n    if (callback) {\n      process.nextTick(callback);\n    }\n\n    return;\n  }\n\n  state.aborted = true;\n  state.debug('id=%d abort', this.id);\n  this.setTimeout(0);\n  var abortCode = code || 'CANCEL';\n  state.framer.rstFrame({\n    id: this.id,\n    code: abortCode\n  });\n  var self = this;\n  process.nextTick(function () {\n    if (callback) {\n      callback(null);\n    }\n\n    self.emit('close', new Error('Aborted, code: ' + abortCode));\n  });\n};\n\nStream.prototype.setPriority = function setPriority(info) {\n  var state = this._spdyState;\n  state.timeout.reset();\n\n  if (!this._checkEnded()) {\n    return;\n  }\n\n  state.debug('id=%d priority change', this.id, info);\n  var frame = {\n    id: this.id,\n    priority: info\n  }; // Change priority on this side\n\n  this._handlePriority(frame); // And on the other too\n\n\n  state.framer.priorityFrame(frame);\n};\n\nStream.prototype.pushPromise = function pushPromise(uri, callback) {\n  if (!this._checkEnded(callback)) {\n    return;\n  }\n\n  var self = this;\n\n  this._hardCork();\n\n  var push = this.connection.pushPromise(this, uri, function (err) {\n    self._hardUncork();\n\n    if (!err) {\n      push._hardUncork();\n    }\n\n    if (callback) {\n      return callback(err, push);\n    }\n\n    if (err) {\n      push.emit('error', err);\n    }\n  });\n\n  push._hardCork();\n\n  return push;\n};\n\nStream.prototype.setMaxChunk = function setMaxChunk(size) {\n  var state = this._spdyState;\n  state.maxChunk = size;\n};\n\nStream.prototype.setTimeout = function setTimeout(delay, callback) {\n  var state = this._spdyState;\n  state.timeout.set(delay, callback);\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/spdy-transport/lib/spdy-transport/stream.js"],"names":["transport","require","assert","util","debug","client","server","Duplex","Stream","connection","options","call","connectionState","_spdyState","state","id","method","path","host","headers","parent","socket","protocol","constants","priority","version","getVersion","isServer","framer","parser","request","needResponse","window","streamWindow","clone","sessionWindow","maxChunk","sent","readable","writable","aborted","corked","corkQueue","timeout","utils","Timeout","on","_onFinish","_onEnd","self","_onWindowOverflow","recv","send","_initPriority","push","_writableState","ended","finished","inherits","exports","prototype","_init","root","priorityRoot","addDefault","add","weight","exclusive","_handleFrame","frame","type","reset","_handleData","_handleHeaders","_handleRST","_handleWindowUpdate","_handlePriority","_handlePushPromise","fin","checkAborted","stream","callback","process","nextTick","Error","_send","data","length","update","dataFrame","getPriority","err","_write","enc","_splitStart","onChunk","_split","offset","local","session","availSession","Math","max","getCurrent","getMax","availLocal","avail","min","limit","size","chunk","slice","_read","isDraining","delta","getDelta","windowUpdateFrame","_readableState","rstFrame","code","emit","abort","remove","_handleResponse","undefined","Buffer","alloc","_maybeClose","_checkEnded","set","_createStream","promisedId","_isGoaway","_hardCork","cork","_hardUncork","uncork","queue","i","_sendPush","status","response","pushFrame","toJSON","_wasSent","requestFrame","respond","responseFrame","setWindow","setMax","sendHeaders","Object","assign","headersFrame","_destroy","destroy","setTimeout","abortCode","setPriority","info","priorityFrame","pushPromise","uri","setMaxChunk","delay"],"mappings":"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","sourcesContent":["'use strict'\n\nvar transport = require('../spdy-transport')\n\nvar assert = require('assert')\nvar util = require('util')\n\nvar debug = {\n  client: require('debug')('spdy:stream:client'),\n  server: require('debug')('spdy:stream:server')\n}\nvar Duplex = require('readable-stream').Duplex\n\nfunction Stream (connection, options) {\n  Duplex.call(this)\n\n  var connectionState = connection._spdyState\n\n  var state = {}\n  this._spdyState = state\n\n  this.id = options.id\n  this.method = options.method\n  this.path = options.path\n  this.host = options.host\n  this.headers = options.headers || {}\n  this.connection = connection\n  this.parent = options.parent || null\n\n  state.socket = null\n  state.protocol = connectionState.protocol\n  state.constants = state.protocol.constants\n\n  // See _initPriority()\n  state.priority = null\n\n  state.version = this.connection.getVersion()\n  state.isServer = this.connection.isServer()\n  state.debug = state.isServer ? debug.server : debug.client\n\n  state.framer = connectionState.framer\n  state.parser = connectionState.parser\n\n  state.request = options.request\n  state.needResponse = options.request\n  state.window = connectionState.streamWindow.clone(options.id)\n  state.sessionWindow = connectionState.window\n  state.maxChunk = connectionState.maxChunk\n\n  // Can't send incoming request\n  // (See `.send()` method)\n  state.sent = !state.request\n\n  state.readable = options.readable !== false\n  state.writable = options.writable !== false\n\n  state.aborted = false\n\n  state.corked = 0\n  state.corkQueue = []\n\n  state.timeout = new transport.utils.Timeout(this)\n\n  this.on('finish', this._onFinish)\n  this.on('end', this._onEnd)\n\n  var self = this\n  function _onWindowOverflow () {\n    self._onWindowOverflow()\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow)\n  state.window.send.on('overflow', _onWindowOverflow)\n\n  this._initPriority(options.priority)\n\n  if (!state.readable) { this.push(null) }\n  if (!state.writable) {\n    this._writableState.ended = true\n    this._writableState.finished = true\n  }\n}\nutil.inherits(Stream, Duplex)\nexports.Stream = Stream\n\nStream.prototype._init = function _init (socket) {\n  this.socket = socket\n}\n\nStream.prototype._initPriority = function _initPriority (priority) {\n  var state = this._spdyState\n  var connectionState = this.connection._spdyState\n  var root = connectionState.priorityRoot\n\n  if (!priority) {\n    state.priority = root.addDefault(this.id)\n    return\n  }\n\n  state.priority = root.add({\n    id: this.id,\n    parent: priority.parent,\n    weight: priority.weight,\n    exclusive: priority.exclusive\n  })\n}\n\nStream.prototype._handleFrame = function _handleFrame (frame) {\n  var state = this._spdyState\n\n  // Ignore any kind of data after abort\n  if (state.aborted) {\n    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type)\n    return\n  }\n\n  // Restart the timer on incoming frames\n  state.timeout.reset()\n\n  if (frame.type === 'DATA') {\n    this._handleData(frame)\n  } else if (frame.type === 'HEADERS') {\n    this._handleHeaders(frame)\n  } else if (frame.type === 'RST') {\n    this._handleRST(frame)\n  } else if (frame.type === 'WINDOW_UPDATE') { this._handleWindowUpdate(frame) } else if (frame.type === 'PRIORITY') {\n    this._handlePriority(frame)\n  } else if (frame.type === 'PUSH_PROMISE') { this._handlePushPromise(frame) }\n\n  if (frame.fin) {\n    state.debug('id=%d end', this.id)\n    this.push(null)\n  }\n}\n\nfunction checkAborted (stream, state, callback) {\n  if (state.aborted) {\n    state.debug('id=%d abort write', stream.id)\n    process.nextTick(function () {\n      callback(new Error('Stream write aborted'))\n    })\n    return true\n  }\n\n  return false\n}\n\nfunction _send (stream, state, data, callback) {\n  if (checkAborted(stream, state, callback)) {\n    return\n  }\n\n  state.debug('id=%d presend=%d', stream.id, data.length)\n\n  state.timeout.reset()\n\n  state.window.send.update(-data.length, function () {\n    if (checkAborted(stream, state, callback)) {\n      return\n    }\n\n    state.debug('id=%d send=%d', stream.id, data.length)\n\n    state.timeout.reset()\n\n    state.framer.dataFrame({\n      id: stream.id,\n      priority: state.priority.getPriority(),\n      fin: false,\n      data: data\n    }, function (err) {\n      state.debug('id=%d postsend=%d', stream.id, data.length)\n      callback(err)\n    })\n  })\n}\n\nStream.prototype._write = function _write (data, enc, callback) {\n  var state = this._spdyState\n\n  // Send the request if it wasn't sent\n  if (!state.sent) { this.send() }\n\n  // Writes should come after pending control frames (response and headers)\n  if (state.corked !== 0) {\n    var self = this\n    state.corkQueue.push(function () {\n      self._write(data, enc, callback)\n    })\n    return\n  }\n\n  // Split DATA in chunks to prevent window from going negative\n  this._splitStart(data, _send, callback)\n}\n\nStream.prototype._splitStart = function _splitStart (data, onChunk, callback) {\n  return this._split(data, 0, onChunk, callback)\n}\n\nStream.prototype._split = function _split (data, offset, onChunk, callback) {\n  if (offset === data.length) {\n    return process.nextTick(callback)\n  }\n\n  var state = this._spdyState\n  var local = state.window.send\n  var session = state.sessionWindow.send\n\n  var availSession = Math.max(0, session.getCurrent())\n  if (availSession === 0) {\n    availSession = session.getMax()\n  }\n  var availLocal = Math.max(0, local.getCurrent())\n  if (availLocal === 0) {\n    availLocal = local.getMax()\n  }\n\n  var avail = Math.min(availSession, availLocal)\n  avail = Math.min(avail, state.maxChunk)\n\n  var self = this\n\n  if (avail === 0) {\n    state.window.send.update(0, function () {\n      self._split(data, offset, onChunk, callback)\n    })\n    return\n  }\n\n  // Split data in chunks in a following way:\n  var limit = avail\n  var size = Math.min(data.length - offset, limit)\n\n  var chunk = data.slice(offset, offset + size)\n\n  onChunk(this, state, chunk, function (err) {\n    if (err) { return callback(err) }\n\n    // Get the next chunk\n    self._split(data, offset + size, onChunk, callback)\n  })\n}\n\nStream.prototype._read = function _read () {\n  var state = this._spdyState\n\n  if (!state.window.recv.isDraining()) {\n    return\n  }\n\n  var delta = state.window.recv.getDelta()\n\n  state.debug('id=%d window emptying, update by %d', this.id, delta)\n\n  state.window.recv.update(delta)\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  })\n}\n\nStream.prototype._handleData = function _handleData (frame) {\n  var state = this._spdyState\n\n  // DATA on ended or not readable stream!\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' })\n    return\n  }\n\n  state.debug('id=%d recv=%d', this.id, frame.data.length)\n  state.window.recv.update(-frame.data.length)\n\n  this.push(frame.data)\n}\n\nStream.prototype._handleRST = function _handleRST (frame) {\n  if (frame.code !== 'CANCEL') {\n    this.emit('error', new Error('Got RST: ' + frame.code))\n  }\n  this.abort()\n}\n\nStream.prototype._handleWindowUpdate = function _handleWindowUpdate (frame) {\n  var state = this._spdyState\n\n  state.window.send.update(frame.delta)\n}\n\nStream.prototype._onWindowOverflow = function _onWindowOverflow () {\n  var state = this._spdyState\n\n  state.debug('id=%d window overflow', this.id)\n  state.framer.rstFrame({ id: this.id, code: 'FLOW_CONTROL_ERROR' })\n\n  this.aborted = true\n  this.emit('error', new Error('HTTP2 window overflow'))\n}\n\nStream.prototype._handlePriority = function _handlePriority (frame) {\n  var state = this._spdyState\n\n  state.priority.remove()\n  state.priority = null\n  this._initPriority(frame.priority)\n\n  // Mostly for testing purposes\n  this.emit('priority', frame.priority)\n}\n\nStream.prototype._handleHeaders = function _handleHeaders (frame) {\n  var state = this._spdyState\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' })\n    return\n  }\n\n  if (state.needResponse) {\n    return this._handleResponse(frame)\n  }\n\n  this.emit('headers', frame.headers)\n}\n\nStream.prototype._handleResponse = function _handleResponse (frame) {\n  var state = this._spdyState\n\n  if (frame.headers[':status'] === undefined) {\n    state.framer.rstFrame({ id: this.id, code: 'PROTOCOL_ERROR' })\n    return\n  }\n\n  state.needResponse = false\n  this.emit('response', frame.headers[':status'] | 0, frame.headers)\n}\n\nStream.prototype._onFinish = function _onFinish () {\n  var state = this._spdyState\n\n  // Send the request if it wasn't sent\n  if (!state.sent) {\n    // NOTE: will send HEADERS with FIN flag\n    this.send()\n  } else {\n    // Just an `.end()` without any writes will trigger immediate `finish` event\n    // without any calls to `_write()`.\n    if (state.corked !== 0) {\n      var self = this\n      state.corkQueue.push(function () {\n        self._onFinish()\n      })\n      return\n    }\n\n    state.framer.dataFrame({\n      id: this.id,\n      priority: state.priority.getPriority(),\n      fin: true,\n      data: Buffer.alloc(0)\n    })\n  }\n\n  this._maybeClose()\n}\n\nStream.prototype._onEnd = function _onEnd () {\n  this._maybeClose()\n}\n\nStream.prototype._checkEnded = function _checkEnded (callback) {\n  var state = this._spdyState\n\n  var ended = false\n  if (state.aborted) { ended = true }\n\n  if (!state.writable || this._writableState.finished) { ended = true }\n\n  if (!ended) {\n    return true\n  }\n\n  if (!callback) {\n    return false\n  }\n\n  var err = new Error('Ended stream can\\'t send frames')\n  process.nextTick(function () {\n    callback(err)\n  })\n\n  return false\n}\n\nStream.prototype._maybeClose = function _maybeClose () {\n  var state = this._spdyState\n\n  // .abort() emits `close`\n  if (state.aborted) {\n    return\n  }\n\n  if ((!state.readable || this._readableState.ended) &&\n      this._writableState.finished) {\n    // Clear timeout\n    state.timeout.set(0)\n\n    this.emit('close')\n  }\n}\n\nStream.prototype._handlePushPromise = function _handlePushPromise (frame) {\n  var push = this.connection._createStream({\n    id: frame.promisedId,\n    parent: this,\n    push: true,\n    request: true,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: false\n  })\n\n  // GOAWAY\n  if (this.connection._isGoaway(push.id)) {\n    return\n  }\n\n  if (!this.emit('pushPromise', push)) {\n    push.abort()\n  }\n}\n\nStream.prototype._hardCork = function _hardCork () {\n  var state = this._spdyState\n\n  this.cork()\n  state.corked++\n}\n\nStream.prototype._hardUncork = function _hardUncork () {\n  var state = this._spdyState\n\n  this.uncork()\n  state.corked--\n  if (state.corked !== 0) {\n    return\n  }\n\n  // Invoke callbacks\n  var queue = state.corkQueue\n  state.corkQueue = []\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n}\n\nStream.prototype._sendPush = function _sendPush (status, response, callback) {\n  var self = this\n  var state = this._spdyState\n\n  this._hardCork()\n  state.framer.pushFrame({\n    id: this.parent.id,\n    promisedId: this.id,\n    priority: state.priority.toJSON(),\n    path: this.path,\n    host: this.host,\n    method: this.method,\n    status: status,\n    headers: this.headers,\n    response: response\n  }, function (err) {\n    self._hardUncork()\n\n    callback(err)\n  })\n}\n\nStream.prototype._wasSent = function _wasSent () {\n  var state = this._spdyState\n  return state.sent\n}\n\n// Public API\n\nStream.prototype.send = function send (callback) {\n  var state = this._spdyState\n\n  if (state.sent) {\n    var err = new Error('Stream was already sent')\n    process.nextTick(function () {\n      if (callback) {\n        callback(err)\n      }\n    })\n    return\n  }\n\n  state.sent = true\n  state.timeout.reset()\n\n  // GET requests should always be auto-finished\n  if (this.method === 'GET') {\n    this._writableState.ended = true\n    this._writableState.finished = true\n  }\n\n  // TODO(indunty): ideally it should just take a stream object as an input\n  var self = this\n  this._hardCork()\n  state.framer.requestFrame({\n    id: this.id,\n    method: this.method,\n    path: this.path,\n    host: this.host,\n    priority: state.priority.toJSON(),\n    headers: this.headers,\n    fin: this._writableState.finished\n  }, function (err) {\n    self._hardUncork()\n\n    if (!callback) {\n      return\n    }\n\n    callback(err)\n  })\n}\n\nStream.prototype.respond = function respond (status, headers, callback) {\n  var self = this\n  var state = this._spdyState\n  assert(!state.request, 'Can\\'t respond on request')\n\n  state.timeout.reset()\n\n  if (!this._checkEnded(callback)) { return }\n\n  var frame = {\n    id: this.id,\n    status: status,\n    headers: headers\n  }\n  this._hardCork()\n  state.framer.responseFrame(frame, function (err) {\n    self._hardUncork()\n    if (callback) { callback(err) }\n  })\n}\n\nStream.prototype.setWindow = function setWindow (size) {\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded()) {\n    return\n  }\n\n  state.debug('id=%d force window max=%d', this.id, size)\n  state.window.recv.setMax(size)\n\n  var delta = state.window.recv.getDelta()\n  if (delta === 0) { return }\n\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  })\n  state.window.recv.update(delta)\n}\n\nStream.prototype.sendHeaders = function sendHeaders (headers, callback) {\n  var self = this\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded(callback)) {\n    return\n  }\n\n  // Request wasn't yet send, coalesce headers\n  if (!state.sent) {\n    this.headers = Object.assign({}, this.headers)\n    Object.assign(this.headers, headers)\n    process.nextTick(function () {\n      if (callback) {\n        callback(null)\n      }\n    })\n    return\n  }\n\n  this._hardCork()\n  state.framer.headersFrame({\n    id: this.id,\n    headers: headers\n  }, function (err) {\n    self._hardUncork()\n    if (callback) { callback(err) }\n  })\n}\n\nStream.prototype._destroy = function destroy () {\n  this.abort()\n}\n\nStream.prototype.abort = function abort (code, callback) {\n  var state = this._spdyState\n\n  // .abort(callback)\n  if (typeof code === 'function') {\n    callback = code\n    code = null\n  }\n\n  if (this._readableState.ended && this._writableState.finished) {\n    state.debug('id=%d already closed', this.id)\n    if (callback) {\n      process.nextTick(callback)\n    }\n    return\n  }\n\n  if (state.aborted) {\n    state.debug('id=%d already aborted', this.id)\n    if (callback) { process.nextTick(callback) }\n    return\n  }\n\n  state.aborted = true\n  state.debug('id=%d abort', this.id)\n\n  this.setTimeout(0)\n\n  var abortCode = code || 'CANCEL'\n\n  state.framer.rstFrame({\n    id: this.id,\n    code: abortCode\n  })\n\n  var self = this\n  process.nextTick(function () {\n    if (callback) {\n      callback(null)\n    }\n    self.emit('close', new Error('Aborted, code: ' + abortCode))\n  })\n}\n\nStream.prototype.setPriority = function setPriority (info) {\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded()) {\n    return\n  }\n\n  state.debug('id=%d priority change', this.id, info)\n\n  var frame = { id: this.id, priority: info }\n\n  // Change priority on this side\n  this._handlePriority(frame)\n\n  // And on the other too\n  state.framer.priorityFrame(frame)\n}\n\nStream.prototype.pushPromise = function pushPromise (uri, callback) {\n  if (!this._checkEnded(callback)) {\n    return\n  }\n\n  var self = this\n  this._hardCork()\n  var push = this.connection.pushPromise(this, uri, function (err) {\n    self._hardUncork()\n    if (!err) {\n      push._hardUncork()\n    }\n\n    if (callback) {\n      return callback(err, push)\n    }\n\n    if (err) { push.emit('error', err) }\n  })\n  push._hardCork()\n\n  return push\n}\n\nStream.prototype.setMaxChunk = function setMaxChunk (size) {\n  var state = this._spdyState\n  state.maxChunk = size\n}\n\nStream.prototype.setTimeout = function setTimeout (delay, callback) {\n  var state = this._spdyState\n\n  state.timeout.set(delay, callback)\n}\n"]},"metadata":{},"sourceType":"script"}