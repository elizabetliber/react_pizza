{"ast":null,"code":"'use strict';\n\nvar parser = exports;\n\nvar transport = require('../../../spdy-transport');\n\nvar base = transport.protocol.base;\nvar utils = base.utils;\n\nvar constants = require('./').constants;\n\nvar assert = require('assert');\n\nvar util = require('util');\n\nfunction Parser(options) {\n  base.Parser.call(this, options);\n  this.isServer = options.isServer;\n  this.waiting = constants.PREFACE_SIZE;\n  this.state = 'preface';\n  this.pendingHeader = null; // Header Block queue\n\n  this._lastHeaderBlock = null;\n  this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE;\n  this.maxHeaderListSize = constants.DEFAULT_MAX_HEADER_LIST_SIZE;\n}\n\nutil.inherits(Parser, base.Parser);\n\nparser.create = function create(options) {\n  return new Parser(options);\n};\n\nParser.prototype.setMaxFrameSize = function setMaxFrameSize(size) {\n  this.maxFrameSize = size;\n};\n\nParser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize(size) {\n  this.maxHeaderListSize = size;\n}; // Only for testing\n\n\nParser.prototype.skipPreface = function skipPreface() {\n  // Just some number bigger than 3.1, doesn't really matter for HTTP2\n  this.setVersion(4); // Parse frame header!\n\n  this.state = 'frame-head';\n  this.waiting = constants.FRAME_HEADER_SIZE;\n};\n\nParser.prototype.execute = function execute(buffer, callback) {\n  if (this.state === 'preface') {\n    return this.onPreface(buffer, callback);\n  }\n\n  if (this.state === 'frame-head') {\n    return this.onFrameHead(buffer, callback);\n  }\n\n  assert(this.state === 'frame-body' && this.pendingHeader !== null);\n  var self = this;\n  var header = this.pendingHeader;\n  this.pendingHeader = null;\n  this.onFrameBody(header, buffer, function (err, frame) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.state = 'frame-head';\n    self.partial = false;\n    self.waiting = constants.FRAME_HEADER_SIZE;\n    callback(null, frame);\n  });\n};\n\nParser.prototype.executePartial = function executePartial(buffer, callback) {\n  var header = this.pendingHeader;\n  assert.strictEqual(header.flags & constants.flags.PADDED, 0);\n\n  if (this.window) {\n    this.window.recv.update(-buffer.size);\n  }\n\n  callback(null, {\n    type: 'DATA',\n    id: header.id,\n    // Partial DATA can't be FIN\n    fin: false,\n    data: buffer.take(buffer.size)\n  });\n};\n\nParser.prototype.onPreface = function onPreface(buffer, callback) {\n  if (buffer.take(buffer.size).toString() !== constants.PREFACE) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid preface'));\n  }\n\n  this.skipPreface();\n  callback(null, null);\n};\n\nParser.prototype.onFrameHead = function onFrameHead(buffer, callback) {\n  var header = {\n    length: buffer.readUInt24BE(),\n    control: true,\n    type: buffer.readUInt8(),\n    flags: buffer.readUInt8(),\n    id: buffer.readUInt32BE() & 0x7fffffff\n  };\n\n  if (header.length > this.maxFrameSize) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'Frame length OOB'));\n  }\n\n  header.control = header.type !== constants.frameType.DATA;\n  this.state = 'frame-body';\n  this.pendingHeader = header;\n  this.waiting = header.length;\n  this.partial = !header.control; // TODO(indutny): eventually support partial padded DATA\n\n  if (this.partial) {\n    this.partial = (header.flags & constants.flags.PADDED) === 0;\n  }\n\n  callback(null, null);\n};\n\nParser.prototype.onFrameBody = function onFrameBody(header, buffer, callback) {\n  var frameType = constants.frameType;\n\n  if (header.type === frameType.DATA) {\n    this.onDataFrame(header, buffer, callback);\n  } else if (header.type === frameType.HEADERS) {\n    this.onHeadersFrame(header, buffer, callback);\n  } else if (header.type === frameType.CONTINUATION) {\n    this.onContinuationFrame(header, buffer, callback);\n  } else if (header.type === frameType.WINDOW_UPDATE) {\n    this.onWindowUpdateFrame(header, buffer, callback);\n  } else if (header.type === frameType.RST_STREAM) {\n    this.onRSTFrame(header, buffer, callback);\n  } else if (header.type === frameType.SETTINGS) {\n    this.onSettingsFrame(header, buffer, callback);\n  } else if (header.type === frameType.PUSH_PROMISE) {\n    this.onPushPromiseFrame(header, buffer, callback);\n  } else if (header.type === frameType.PING) {\n    this.onPingFrame(header, buffer, callback);\n  } else if (header.type === frameType.GOAWAY) {\n    this.onGoawayFrame(header, buffer, callback);\n  } else if (header.type === frameType.PRIORITY) {\n    this.onPriorityFrame(header, buffer, callback);\n  } else if (header.type === frameType.X_FORWARDED_FOR) {\n    this.onXForwardedFrame(header, buffer, callback);\n  } else {\n    this.onUnknownFrame(header, buffer, callback);\n  }\n};\n\nParser.prototype.onUnknownFrame = function onUnknownFrame(header, buffer, callback) {\n  if (this._lastHeaderBlock !== null) {\n    callback(this.error(constants.error.PROTOCOL_ERROR, 'Received unknown frame in the middle of a header block'));\n    return;\n  }\n\n  callback(null, {\n    type: 'unknown: ' + header.type\n  });\n};\n\nParser.prototype.unpadData = function unpadData(header, body, callback) {\n  var isPadded = (header.flags & constants.flags.PADDED) !== 0;\n\n  if (!isPadded) {\n    return callback(null, body);\n  }\n\n  if (!body.has(1)) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'Not enough space for padding'));\n  }\n\n  var pad = body.readUInt8();\n\n  if (!body.has(pad)) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid padding size'));\n  }\n\n  var contents = body.clone(body.size - pad);\n  body.skip(body.size);\n  callback(null, contents);\n};\n\nParser.prototype.onDataFrame = function onDataFrame(header, body, callback) {\n  var isEndStream = (header.flags & constants.flags.END_STREAM) !== 0;\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Received DATA frame with stream=0'));\n  } // Count received bytes\n\n\n  if (this.window) {\n    this.window.recv.update(-body.size);\n  }\n\n  this.unpadData(header, body, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, {\n      type: 'DATA',\n      id: header.id,\n      fin: isEndStream,\n      data: data.take(data.size)\n    });\n  });\n};\n\nParser.prototype.initHeaderBlock = function initHeaderBlock(header, frame, block, callback) {\n  if (this._lastHeaderBlock) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Duplicate Stream ID'));\n  }\n\n  this._lastHeaderBlock = {\n    id: header.id,\n    frame: frame,\n    queue: [],\n    size: 0\n  };\n  this.queueHeaderBlock(header, block, callback);\n};\n\nParser.prototype.queueHeaderBlock = function queueHeaderBlock(header, block, callback) {\n  var self = this;\n  var item = this._lastHeaderBlock;\n\n  if (!this._lastHeaderBlock || item.id !== header.id) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'No matching stream for continuation'));\n  }\n\n  var fin = (header.flags & constants.flags.END_HEADERS) !== 0;\n  var chunks = block.toChunks();\n\n  for (var i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i];\n    item.queue.push(chunk);\n    item.size += chunk.length;\n  }\n\n  if (item.size >= self.maxHeaderListSize) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Compressed header list is too large'));\n  }\n\n  if (!fin) {\n    return callback(null, null);\n  }\n\n  this._lastHeaderBlock = null;\n  this.decompress.write(item.queue, function (err, chunks) {\n    if (err) {\n      return callback(self.error(constants.error.COMPRESSION_ERROR, err.message));\n    }\n\n    var headers = {};\n    var size = 0;\n\n    for (var i = 0; i < chunks.length; i++) {\n      var header = chunks[i];\n      size += header.name.length + header.value.length + 32;\n\n      if (size >= self.maxHeaderListSize) {\n        return callback(self.error(constants.error.PROTOCOL_ERROR, 'Header list is too large'));\n      }\n\n      if (/[A-Z]/.test(header.name)) {\n        return callback(self.error(constants.error.PROTOCOL_ERROR, 'Header name must be lowercase'));\n      }\n\n      utils.addHeaderLine(header.name, header.value, headers);\n    }\n\n    item.frame.headers = headers;\n    item.frame.path = headers[':path'];\n    callback(null, item.frame);\n  });\n};\n\nParser.prototype.onHeadersFrame = function onHeadersFrame(header, body, callback) {\n  var self = this;\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for HEADERS'));\n  }\n\n  this.unpadData(header, body, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    var isPriority = (header.flags & constants.flags.PRIORITY) !== 0;\n\n    if (!data.has(isPriority ? 5 : 0)) {\n      return callback(self.error(constants.error.FRAME_SIZE_ERROR, 'Not enough data for HEADERS'));\n    }\n\n    var exclusive = false;\n    var dependency = 0;\n    var weight = constants.DEFAULT_WEIGHT;\n\n    if (isPriority) {\n      dependency = data.readUInt32BE();\n      exclusive = (dependency & 0x80000000) !== 0;\n      dependency &= 0x7fffffff; // Weight's range is [1, 256]\n\n      weight = data.readUInt8() + 1;\n    }\n\n    if (dependency === header.id) {\n      return callback(self.error(constants.error.PROTOCOL_ERROR, 'Stream can\\'t dependend on itself'));\n    }\n\n    var streamInfo = {\n      type: 'HEADERS',\n      id: header.id,\n      priority: {\n        parent: dependency,\n        exclusive: exclusive,\n        weight: weight\n      },\n      fin: (header.flags & constants.flags.END_STREAM) !== 0,\n      writable: true,\n      headers: null,\n      path: null\n    };\n    self.initHeaderBlock(header, streamInfo, data, callback);\n  });\n};\n\nParser.prototype.onContinuationFrame = function onContinuationFrame(header, body, callback) {\n  this.queueHeaderBlock(header, body, callback);\n};\n\nParser.prototype.onRSTFrame = function onRSTFrame(header, body, callback) {\n  if (body.size !== 4) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'RST_STREAM length not 4'));\n  }\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for RST_STREAM'));\n  }\n\n  callback(null, {\n    type: 'RST',\n    id: header.id,\n    code: constants.errorByCode[body.readUInt32BE()]\n  });\n};\n\nParser.prototype._validateSettings = function _validateSettings(settings) {\n  if (settings['enable_push'] !== undefined && settings['enable_push'] !== 0 && settings['enable_push'] !== 1) {\n    return this.error(constants.error.PROTOCOL_ERROR, 'SETTINGS_ENABLE_PUSH must be 0 or 1');\n  }\n\n  if (settings['initial_window_size'] !== undefined && (settings['initial_window_size'] > constants.MAX_INITIAL_WINDOW_SIZE || settings['initial_window_size'] < 0)) {\n    return this.error(constants.error.FLOW_CONTROL_ERROR, 'SETTINGS_INITIAL_WINDOW_SIZE is OOB');\n  }\n\n  if (settings['max_frame_size'] !== undefined && (settings['max_frame_size'] > constants.ABSOLUTE_MAX_FRAME_SIZE || settings['max_frame_size'] < constants.INITIAL_MAX_FRAME_SIZE)) {\n    return this.error(constants.error.PROTOCOL_ERROR, 'SETTINGS_MAX_FRAME_SIZE is OOB');\n  }\n\n  return undefined;\n};\n\nParser.prototype.onSettingsFrame = function onSettingsFrame(header, body, callback) {\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for SETTINGS'));\n  }\n\n  var isAck = (header.flags & constants.flags.ACK) !== 0;\n\n  if (isAck && body.size !== 0) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'SETTINGS with ACK and non-zero length'));\n  }\n\n  if (isAck) {\n    return callback(null, {\n      type: 'ACK_SETTINGS'\n    });\n  }\n\n  if (body.size % 6 !== 0) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'SETTINGS length not multiple of 6'));\n  }\n\n  var settings = {};\n\n  while (!body.isEmpty()) {\n    var id = body.readUInt16BE();\n    var value = body.readUInt32BE();\n    var name = constants.settingsIndex[id];\n\n    if (name) {\n      settings[name] = value;\n    }\n  }\n\n  var err = this._validateSettings(settings);\n\n  if (err !== undefined) {\n    return callback(err);\n  }\n\n  callback(null, {\n    type: 'SETTINGS',\n    settings: settings\n  });\n};\n\nParser.prototype.onPushPromiseFrame = function onPushPromiseFrame(header, body, callback) {\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for PUSH_PROMISE'));\n  }\n\n  var self = this;\n  this.unpadData(header, body, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!data.has(4)) {\n      return callback(self.error(constants.error.FRAME_SIZE_ERROR, 'PUSH_PROMISE length less than 4'));\n    }\n\n    var streamInfo = {\n      type: 'PUSH_PROMISE',\n      id: header.id,\n      fin: false,\n      promisedId: data.readUInt32BE() & 0x7fffffff,\n      headers: null,\n      path: null\n    };\n    self.initHeaderBlock(header, streamInfo, data, callback);\n  });\n};\n\nParser.prototype.onPingFrame = function onPingFrame(header, body, callback) {\n  if (body.size !== 8) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'PING length != 8'));\n  }\n\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for PING'));\n  }\n\n  var ack = (header.flags & constants.flags.ACK) !== 0;\n  callback(null, {\n    type: 'PING',\n    opaque: body.take(body.size),\n    ack: ack\n  });\n};\n\nParser.prototype.onGoawayFrame = function onGoawayFrame(header, body, callback) {\n  if (!body.has(8)) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'GOAWAY length < 8'));\n  }\n\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for GOAWAY'));\n  }\n\n  var frame = {\n    type: 'GOAWAY',\n    lastId: body.readUInt32BE(),\n    code: constants.goawayByCode[body.readUInt32BE()]\n  };\n\n  if (body.size !== 0) {\n    frame.debug = body.take(body.size);\n  }\n\n  callback(null, frame);\n};\n\nParser.prototype.onPriorityFrame = function onPriorityFrame(header, body, callback) {\n  if (body.size !== 5) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'PRIORITY length != 5'));\n  }\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for PRIORITY'));\n  }\n\n  var dependency = body.readUInt32BE(); // Again the range is from 1 to 256\n\n  var weight = body.readUInt8() + 1;\n\n  if (dependency === header.id) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'Stream can\\'t dependend on itself'));\n  }\n\n  callback(null, {\n    type: 'PRIORITY',\n    id: header.id,\n    priority: {\n      exclusive: (dependency & 0x80000000) !== 0,\n      parent: dependency & 0x7fffffff,\n      weight: weight\n    }\n  });\n};\n\nParser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame(header, body, callback) {\n  if (body.size !== 4) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'WINDOW_UPDATE length != 4'));\n  }\n\n  var delta = body.readInt32BE();\n\n  if (delta === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR, 'WINDOW_UPDATE delta == 0'));\n  }\n\n  callback(null, {\n    type: 'WINDOW_UPDATE',\n    id: header.id,\n    delta: delta\n  });\n};\n\nParser.prototype.onXForwardedFrame = function onXForwardedFrame(header, body, callback) {\n  callback(null, {\n    type: 'X_FORWARDED_FOR',\n    host: body.take(body.size).toString()\n  });\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/spdy-transport/lib/spdy-transport/protocol/http2/parser.js"],"names":["parser","exports","transport","require","base","protocol","utils","constants","assert","util","Parser","options","call","isServer","waiting","PREFACE_SIZE","state","pendingHeader","_lastHeaderBlock","maxFrameSize","INITIAL_MAX_FRAME_SIZE","maxHeaderListSize","DEFAULT_MAX_HEADER_LIST_SIZE","inherits","create","prototype","setMaxFrameSize","size","setMaxHeaderListSize","skipPreface","setVersion","FRAME_HEADER_SIZE","execute","buffer","callback","onPreface","onFrameHead","self","header","onFrameBody","err","frame","partial","executePartial","strictEqual","flags","PADDED","window","recv","update","type","id","fin","data","take","toString","PREFACE","error","PROTOCOL_ERROR","length","readUInt24BE","control","readUInt8","readUInt32BE","FRAME_SIZE_ERROR","frameType","DATA","onDataFrame","HEADERS","onHeadersFrame","CONTINUATION","onContinuationFrame","WINDOW_UPDATE","onWindowUpdateFrame","RST_STREAM","onRSTFrame","SETTINGS","onSettingsFrame","PUSH_PROMISE","onPushPromiseFrame","PING","onPingFrame","GOAWAY","onGoawayFrame","PRIORITY","onPriorityFrame","X_FORWARDED_FOR","onXForwardedFrame","onUnknownFrame","unpadData","body","isPadded","has","pad","contents","clone","skip","isEndStream","END_STREAM","initHeaderBlock","block","queue","queueHeaderBlock","item","END_HEADERS","chunks","toChunks","i","chunk","push","decompress","write","COMPRESSION_ERROR","message","headers","name","value","test","addHeaderLine","path","isPriority","exclusive","dependency","weight","DEFAULT_WEIGHT","streamInfo","priority","parent","writable","code","errorByCode","_validateSettings","settings","undefined","MAX_INITIAL_WINDOW_SIZE","FLOW_CONTROL_ERROR","ABSOLUTE_MAX_FRAME_SIZE","isAck","ACK","isEmpty","readUInt16BE","settingsIndex","promisedId","ack","opaque","lastId","goawayByCode","debug","delta","readInt32BE","host"],"mappings":"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","sourcesContent":["'use strict'\n\nvar parser = exports\n\nvar transport = require('../../../spdy-transport')\nvar base = transport.protocol.base\nvar utils = base.utils\nvar constants = require('./').constants\n\nvar assert = require('assert')\nvar util = require('util')\n\nfunction Parser (options) {\n  base.Parser.call(this, options)\n\n  this.isServer = options.isServer\n\n  this.waiting = constants.PREFACE_SIZE\n  this.state = 'preface'\n  this.pendingHeader = null\n\n  // Header Block queue\n  this._lastHeaderBlock = null\n  this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE\n  this.maxHeaderListSize = constants.DEFAULT_MAX_HEADER_LIST_SIZE\n}\nutil.inherits(Parser, base.Parser)\n\nparser.create = function create (options) {\n  return new Parser(options)\n}\n\nParser.prototype.setMaxFrameSize = function setMaxFrameSize (size) {\n  this.maxFrameSize = size\n}\n\nParser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize (size) {\n  this.maxHeaderListSize = size\n}\n\n// Only for testing\nParser.prototype.skipPreface = function skipPreface () {\n  // Just some number bigger than 3.1, doesn't really matter for HTTP2\n  this.setVersion(4)\n\n  // Parse frame header!\n  this.state = 'frame-head'\n  this.waiting = constants.FRAME_HEADER_SIZE\n}\n\nParser.prototype.execute = function execute (buffer, callback) {\n  if (this.state === 'preface') { return this.onPreface(buffer, callback) }\n\n  if (this.state === 'frame-head') {\n    return this.onFrameHead(buffer, callback)\n  }\n\n  assert(this.state === 'frame-body' && this.pendingHeader !== null)\n\n  var self = this\n  var header = this.pendingHeader\n  this.pendingHeader = null\n\n  this.onFrameBody(header, buffer, function (err, frame) {\n    if (err) {\n      return callback(err)\n    }\n\n    self.state = 'frame-head'\n    self.partial = false\n    self.waiting = constants.FRAME_HEADER_SIZE\n    callback(null, frame)\n  })\n}\n\nParser.prototype.executePartial = function executePartial (buffer, callback) {\n  var header = this.pendingHeader\n\n  assert.strictEqual(header.flags & constants.flags.PADDED, 0)\n\n  if (this.window) { this.window.recv.update(-buffer.size) }\n\n  callback(null, {\n    type: 'DATA',\n    id: header.id,\n\n    // Partial DATA can't be FIN\n    fin: false,\n    data: buffer.take(buffer.size)\n  })\n}\n\nParser.prototype.onPreface = function onPreface (buffer, callback) {\n  if (buffer.take(buffer.size).toString() !== constants.PREFACE) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid preface'))\n  }\n\n  this.skipPreface()\n  callback(null, null)\n}\n\nParser.prototype.onFrameHead = function onFrameHead (buffer, callback) {\n  var header = {\n    length: buffer.readUInt24BE(),\n    control: true,\n    type: buffer.readUInt8(),\n    flags: buffer.readUInt8(),\n    id: buffer.readUInt32BE() & 0x7fffffff\n  }\n\n  if (header.length > this.maxFrameSize) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'Frame length OOB'))\n  }\n\n  header.control = header.type !== constants.frameType.DATA\n\n  this.state = 'frame-body'\n  this.pendingHeader = header\n  this.waiting = header.length\n  this.partial = !header.control\n\n  // TODO(indutny): eventually support partial padded DATA\n  if (this.partial) {\n    this.partial = (header.flags & constants.flags.PADDED) === 0\n  }\n\n  callback(null, null)\n}\n\nParser.prototype.onFrameBody = function onFrameBody (header, buffer, callback) {\n  var frameType = constants.frameType\n\n  if (header.type === frameType.DATA) {\n    this.onDataFrame(header, buffer, callback)\n  } else if (header.type === frameType.HEADERS) {\n    this.onHeadersFrame(header, buffer, callback)\n  } else if (header.type === frameType.CONTINUATION) {\n    this.onContinuationFrame(header, buffer, callback)\n  } else if (header.type === frameType.WINDOW_UPDATE) {\n    this.onWindowUpdateFrame(header, buffer, callback)\n  } else if (header.type === frameType.RST_STREAM) {\n    this.onRSTFrame(header, buffer, callback)\n  } else if (header.type === frameType.SETTINGS) {\n    this.onSettingsFrame(header, buffer, callback)\n  } else if (header.type === frameType.PUSH_PROMISE) {\n    this.onPushPromiseFrame(header, buffer, callback)\n  } else if (header.type === frameType.PING) {\n    this.onPingFrame(header, buffer, callback)\n  } else if (header.type === frameType.GOAWAY) {\n    this.onGoawayFrame(header, buffer, callback)\n  } else if (header.type === frameType.PRIORITY) {\n    this.onPriorityFrame(header, buffer, callback)\n  } else if (header.type === frameType.X_FORWARDED_FOR) {\n    this.onXForwardedFrame(header, buffer, callback)\n  } else {\n    this.onUnknownFrame(header, buffer, callback)\n  }\n}\n\nParser.prototype.onUnknownFrame = function onUnknownFrame (header, buffer, callback) {\n  if (this._lastHeaderBlock !== null) {\n    callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Received unknown frame in the middle of a header block'))\n    return\n  }\n  callback(null, { type: 'unknown: ' + header.type })\n}\n\nParser.prototype.unpadData = function unpadData (header, body, callback) {\n  var isPadded = (header.flags & constants.flags.PADDED) !== 0\n\n  if (!isPadded) { return callback(null, body) }\n\n  if (!body.has(1)) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'Not enough space for padding'))\n  }\n\n  var pad = body.readUInt8()\n  if (!body.has(pad)) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid padding size'))\n  }\n\n  var contents = body.clone(body.size - pad)\n  body.skip(body.size)\n  callback(null, contents)\n}\n\nParser.prototype.onDataFrame = function onDataFrame (header, body, callback) {\n  var isEndStream = (header.flags & constants.flags.END_STREAM) !== 0\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Received DATA frame with stream=0'))\n  }\n\n  // Count received bytes\n  if (this.window) {\n    this.window.recv.update(-body.size)\n  }\n\n  this.unpadData(header, body, function (err, data) {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, {\n      type: 'DATA',\n      id: header.id,\n      fin: isEndStream,\n      data: data.take(data.size)\n    })\n  })\n}\n\nParser.prototype.initHeaderBlock = function initHeaderBlock (header,\n  frame,\n  block,\n  callback) {\n  if (this._lastHeaderBlock) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Duplicate Stream ID'))\n  }\n\n  this._lastHeaderBlock = {\n    id: header.id,\n    frame: frame,\n    queue: [],\n    size: 0\n  }\n\n  this.queueHeaderBlock(header, block, callback)\n}\n\nParser.prototype.queueHeaderBlock = function queueHeaderBlock (header,\n  block,\n  callback) {\n  var self = this\n  var item = this._lastHeaderBlock\n  if (!this._lastHeaderBlock || item.id !== header.id) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'No matching stream for continuation'))\n  }\n\n  var fin = (header.flags & constants.flags.END_HEADERS) !== 0\n\n  var chunks = block.toChunks()\n  for (var i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i]\n    item.queue.push(chunk)\n    item.size += chunk.length\n  }\n\n  if (item.size >= self.maxHeaderListSize) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Compressed header list is too large'))\n  }\n\n  if (!fin) { return callback(null, null) }\n  this._lastHeaderBlock = null\n\n  this.decompress.write(item.queue, function (err, chunks) {\n    if (err) {\n      return callback(self.error(constants.error.COMPRESSION_ERROR,\n        err.message))\n    }\n\n    var headers = {}\n    var size = 0\n    for (var i = 0; i < chunks.length; i++) {\n      var header = chunks[i]\n\n      size += header.name.length + header.value.length + 32\n      if (size >= self.maxHeaderListSize) {\n        return callback(self.error(constants.error.PROTOCOL_ERROR,\n          'Header list is too large'))\n      }\n\n      if (/[A-Z]/.test(header.name)) {\n        return callback(self.error(constants.error.PROTOCOL_ERROR,\n          'Header name must be lowercase'))\n      }\n\n      utils.addHeaderLine(header.name, header.value, headers)\n    }\n\n    item.frame.headers = headers\n    item.frame.path = headers[':path']\n\n    callback(null, item.frame)\n  })\n}\n\nParser.prototype.onHeadersFrame = function onHeadersFrame (header,\n  body,\n  callback) {\n  var self = this\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid stream id for HEADERS'))\n  }\n\n  this.unpadData(header, body, function (err, data) {\n    if (err) { return callback(err) }\n\n    var isPriority = (header.flags & constants.flags.PRIORITY) !== 0\n    if (!data.has(isPriority ? 5 : 0)) {\n      return callback(self.error(constants.error.FRAME_SIZE_ERROR,\n        'Not enough data for HEADERS'))\n    }\n\n    var exclusive = false\n    var dependency = 0\n    var weight = constants.DEFAULT_WEIGHT\n    if (isPriority) {\n      dependency = data.readUInt32BE()\n      exclusive = (dependency & 0x80000000) !== 0\n      dependency &= 0x7fffffff\n\n      // Weight's range is [1, 256]\n      weight = data.readUInt8() + 1\n    }\n\n    if (dependency === header.id) {\n      return callback(self.error(constants.error.PROTOCOL_ERROR,\n        'Stream can\\'t dependend on itself'))\n    }\n\n    var streamInfo = {\n      type: 'HEADERS',\n      id: header.id,\n      priority: {\n        parent: dependency,\n        exclusive: exclusive,\n        weight: weight\n      },\n      fin: (header.flags & constants.flags.END_STREAM) !== 0,\n      writable: true,\n      headers: null,\n      path: null\n    }\n\n    self.initHeaderBlock(header, streamInfo, data, callback)\n  })\n}\n\nParser.prototype.onContinuationFrame = function onContinuationFrame (header,\n  body,\n  callback) {\n  this.queueHeaderBlock(header, body, callback)\n}\n\nParser.prototype.onRSTFrame = function onRSTFrame (header, body, callback) {\n  if (body.size !== 4) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'RST_STREAM length not 4'))\n  }\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid stream id for RST_STREAM'))\n  }\n\n  callback(null, {\n    type: 'RST',\n    id: header.id,\n    code: constants.errorByCode[body.readUInt32BE()]\n  })\n}\n\nParser.prototype._validateSettings = function _validateSettings (settings) {\n  if (settings['enable_push'] !== undefined &&\n      settings['enable_push'] !== 0 &&\n      settings['enable_push'] !== 1) {\n    return this.error(constants.error.PROTOCOL_ERROR,\n      'SETTINGS_ENABLE_PUSH must be 0 or 1')\n  }\n\n  if (settings['initial_window_size'] !== undefined &&\n      (settings['initial_window_size'] > constants.MAX_INITIAL_WINDOW_SIZE ||\n       settings['initial_window_size'] < 0)) {\n    return this.error(constants.error.FLOW_CONTROL_ERROR,\n      'SETTINGS_INITIAL_WINDOW_SIZE is OOB')\n  }\n\n  if (settings['max_frame_size'] !== undefined &&\n      (settings['max_frame_size'] > constants.ABSOLUTE_MAX_FRAME_SIZE ||\n       settings['max_frame_size'] < constants.INITIAL_MAX_FRAME_SIZE)) {\n    return this.error(constants.error.PROTOCOL_ERROR,\n      'SETTINGS_MAX_FRAME_SIZE is OOB')\n  }\n\n  return undefined\n}\n\nParser.prototype.onSettingsFrame = function onSettingsFrame (header,\n  body,\n  callback) {\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid stream id for SETTINGS'))\n  }\n\n  var isAck = (header.flags & constants.flags.ACK) !== 0\n  if (isAck && body.size !== 0) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'SETTINGS with ACK and non-zero length'))\n  }\n\n  if (isAck) {\n    return callback(null, { type: 'ACK_SETTINGS' })\n  }\n\n  if (body.size % 6 !== 0) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'SETTINGS length not multiple of 6'))\n  }\n\n  var settings = {}\n  while (!body.isEmpty()) {\n    var id = body.readUInt16BE()\n    var value = body.readUInt32BE()\n    var name = constants.settingsIndex[id]\n\n    if (name) {\n      settings[name] = value\n    }\n  }\n\n  var err = this._validateSettings(settings)\n  if (err !== undefined) {\n    return callback(err)\n  }\n\n  callback(null, {\n    type: 'SETTINGS',\n    settings: settings\n  })\n}\n\nParser.prototype.onPushPromiseFrame = function onPushPromiseFrame (header,\n  body,\n  callback) {\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid stream id for PUSH_PROMISE'))\n  }\n\n  var self = this\n  this.unpadData(header, body, function (err, data) {\n    if (err) {\n      return callback(err)\n    }\n\n    if (!data.has(4)) {\n      return callback(self.error(constants.error.FRAME_SIZE_ERROR,\n        'PUSH_PROMISE length less than 4'))\n    }\n\n    var streamInfo = {\n      type: 'PUSH_PROMISE',\n      id: header.id,\n      fin: false,\n      promisedId: data.readUInt32BE() & 0x7fffffff,\n      headers: null,\n      path: null\n    }\n\n    self.initHeaderBlock(header, streamInfo, data, callback)\n  })\n}\n\nParser.prototype.onPingFrame = function onPingFrame (header, body, callback) {\n  if (body.size !== 8) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'PING length != 8'))\n  }\n\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid stream id for PING'))\n  }\n\n  var ack = (header.flags & constants.flags.ACK) !== 0\n  callback(null, { type: 'PING', opaque: body.take(body.size), ack: ack })\n}\n\nParser.prototype.onGoawayFrame = function onGoawayFrame (header,\n  body,\n  callback) {\n  if (!body.has(8)) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'GOAWAY length < 8'))\n  }\n\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid stream id for GOAWAY'))\n  }\n\n  var frame = {\n    type: 'GOAWAY',\n    lastId: body.readUInt32BE(),\n    code: constants.goawayByCode[body.readUInt32BE()]\n  }\n\n  if (body.size !== 0) { frame.debug = body.take(body.size) }\n\n  callback(null, frame)\n}\n\nParser.prototype.onPriorityFrame = function onPriorityFrame (header,\n  body,\n  callback) {\n  if (body.size !== 5) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'PRIORITY length != 5'))\n  }\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Invalid stream id for PRIORITY'))\n  }\n\n  var dependency = body.readUInt32BE()\n\n  // Again the range is from 1 to 256\n  var weight = body.readUInt8() + 1\n\n  if (dependency === header.id) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'Stream can\\'t dependend on itself'))\n  }\n\n  callback(null, {\n    type: 'PRIORITY',\n    id: header.id,\n    priority: {\n      exclusive: (dependency & 0x80000000) !== 0,\n      parent: dependency & 0x7fffffff,\n      weight: weight\n    }\n  })\n}\n\nParser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame (header,\n  body,\n  callback) {\n  if (body.size !== 4) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n      'WINDOW_UPDATE length != 4'))\n  }\n\n  var delta = body.readInt32BE()\n  if (delta === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n      'WINDOW_UPDATE delta == 0'))\n  }\n\n  callback(null, {\n    type: 'WINDOW_UPDATE',\n    id: header.id,\n    delta: delta\n  })\n}\n\nParser.prototype.onXForwardedFrame = function onXForwardedFrame (header,\n  body,\n  callback) {\n  callback(null, {\n    type: 'X_FORWARDED_FOR',\n    host: body.take(body.size).toString()\n  })\n}\n"]},"metadata":{},"sourceType":"script"}