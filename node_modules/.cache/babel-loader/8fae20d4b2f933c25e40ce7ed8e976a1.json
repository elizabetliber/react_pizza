{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar thing = require('handle-thing');\n\nvar httpDeceiver = require('http-deceiver');\n\nvar util = require('util');\n\nfunction Handle(options, stream, socket) {\n  var state = {};\n  this._spdyState = state;\n  state.options = options || {};\n  state.stream = stream;\n  state.socket = null;\n  state.rawSocket = socket || stream.connection.socket;\n  state.deceiver = null;\n  state.ending = false;\n  var self = this;\n  thing.call(this, stream, {\n    getPeerName: function () {\n      return self._getPeerName();\n    },\n    close: function (callback) {\n      return self._closeCallback(callback);\n    }\n  });\n\n  if (!state.stream) {\n    this.on('stream', function (stream) {\n      state.stream = stream;\n    });\n  }\n}\n\nutil.inherits(Handle, thing);\nmodule.exports = Handle;\n\nHandle.create = function create(options, stream, socket) {\n  return new Handle(options, stream, socket);\n};\n\nHandle.prototype._getPeerName = function _getPeerName() {\n  var state = this._spdyState;\n\n  if (state.rawSocket._getpeername) {\n    return state.rawSocket._getpeername();\n  }\n\n  return null;\n};\n\nHandle.prototype._closeCallback = function _closeCallback(callback) {\n  var state = this._spdyState;\n  var stream = state.stream;\n\n  if (state.ending) {\n    // The .end() method of the stream may be called by us or by the\n    // .shutdown() method in our super-class. If the latter has already been\n    // called, then calling the .end() method below will have no effect, with\n    // the result that the callback will never get executed, leading to an ever\n    // so subtle memory leak.\n    if (stream._writableState.finished) {\n      // NOTE: it is important to call `setImmediate` instead of `nextTick`,\n      // since this is how regular `handle.close()` works in node.js core.\n      //\n      // Using `nextTick` will lead to `net.Socket` emitting `close` before\n      // `end` on UV_EOF. This results in aborted request without `end` event.\n      setImmediate(callback);\n    } else if (stream._writableState.ending) {\n      stream.once('finish', function () {\n        callback(null);\n      });\n    } else {\n      stream.end(callback);\n    }\n  } else {\n    stream.abort(callback);\n  } // Only a single end is allowed\n\n\n  state.ending = false;\n};\n\nHandle.prototype.getStream = function getStream(callback) {\n  var state = this._spdyState;\n\n  if (!callback) {\n    assert(state.stream);\n    return state.stream;\n  }\n\n  if (state.stream) {\n    process.nextTick(function () {\n      callback(state.stream);\n    });\n    return;\n  }\n\n  this.on('stream', callback);\n};\n\nHandle.prototype.assignSocket = function assignSocket(socket, options) {\n  var state = this._spdyState;\n  state.socket = socket;\n  state.deceiver = httpDeceiver.create(socket, options);\n\n  function onStreamError(err) {\n    state.socket.emit('error', err);\n  }\n\n  this.getStream(function (stream) {\n    stream.on('error', onStreamError);\n  });\n};\n\nHandle.prototype.assignClientRequest = function assignClientRequest(req) {\n  var state = this._spdyState;\n  var oldEnd = req.end;\n  var oldSend = req._send; // Catch the headers before request will be sent\n\n  var self = this; // For old nodes\n\n  if (thing.mode !== 'modern') {\n    req.end = function end() {\n      this.end = oldEnd;\n\n      this._send('');\n\n      return this.end.apply(this, arguments);\n    };\n  }\n\n  req._send = function send(data) {\n    this._headerSent = true; // for v0.10 and below, otherwise it will set `hot = false` and include\n    // headers in first write\n\n    this._header = 'ignore me'; // To prevent exception\n\n    this.connection = state.socket; // It is very important to leave this here, otherwise it will be executed\n    // on a next tick, after `_send` will perform write\n\n    self.getStream(function (stream) {\n      if (!stream.connection._isGoaway(stream.id)) {\n        stream.send();\n      }\n    }); // We are ready to create stream\n\n    self.emit('needStream'); // Ensure that the connection is still ok to use\n\n    if (state.stream && state.stream.connection._isGoaway(state.stream.id)) {\n      return;\n    }\n\n    req._send = oldSend; // Ignore empty writes\n\n    if (req.method === 'GET' && data.length === 0) {\n      return;\n    }\n\n    return req._send.apply(this, arguments);\n  }; // No chunked encoding\n\n\n  req.useChunkedEncodingByDefault = false;\n  req.on('finish', function () {\n    req.socket.end();\n  });\n};\n\nHandle.prototype.assignRequest = function assignRequest(req) {\n  // Emit trailing headers\n  this.getStream(function (stream) {\n    stream.on('headers', function (headers) {\n      req.emit('trailers', headers);\n    });\n  });\n};\n\nHandle.prototype.assignResponse = function assignResponse(res) {\n  var self = this;\n\n  res.addTrailers = function addTrailers(headers) {\n    self.getStream(function (stream) {\n      stream.sendHeaders(headers);\n    });\n  };\n};\n\nHandle.prototype._transformHeaders = function _transformHeaders(kind, headers) {\n  var state = this._spdyState;\n  var res = {};\n  var keys = Object.keys(headers);\n\n  if (kind === 'request' && state.options['x-forwarded-for']) {\n    var xforwarded = state.stream.connection.getXForwardedFor();\n\n    if (xforwarded !== null) {\n      res['x-forwarded-for'] = xforwarded;\n    }\n  }\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = headers[key];\n\n    if (key === ':authority') {\n      res.host = value;\n    }\n\n    if (/^:/.test(key)) {\n      continue;\n    }\n\n    res[key] = value;\n  }\n\n  return res;\n};\n\nHandle.prototype.emitRequest = function emitRequest() {\n  var state = this._spdyState;\n  var stream = state.stream;\n  state.deceiver.emitRequest({\n    method: stream.method,\n    path: stream.path,\n    headers: this._transformHeaders('request', stream.headers)\n  });\n};\n\nHandle.prototype.emitResponse = function emitResponse(status, headers) {\n  var state = this._spdyState;\n  state.deceiver.emitResponse({\n    status: status,\n    headers: this._transformHeaders('response', headers)\n  });\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/spdy/lib/spdy/handle.js"],"names":["assert","require","thing","httpDeceiver","util","Handle","options","stream","socket","state","_spdyState","rawSocket","connection","deceiver","ending","self","call","getPeerName","_getPeerName","close","callback","_closeCallback","on","inherits","module","exports","create","prototype","_getpeername","_writableState","finished","setImmediate","once","end","abort","getStream","process","nextTick","assignSocket","onStreamError","err","emit","assignClientRequest","req","oldEnd","oldSend","_send","mode","apply","arguments","send","data","_headerSent","_header","_isGoaway","id","method","length","useChunkedEncodingByDefault","assignRequest","headers","assignResponse","res","addTrailers","sendHeaders","_transformHeaders","kind","keys","Object","xforwarded","getXForwardedFor","i","key","value","host","test","emitRequest","path","emitResponse","status"],"mappings":"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","sourcesContent":["'use strict'\n\nvar assert = require('assert')\nvar thing = require('handle-thing')\nvar httpDeceiver = require('http-deceiver')\nvar util = require('util')\n\nfunction Handle (options, stream, socket) {\n  var state = {}\n  this._spdyState = state\n\n  state.options = options || {}\n\n  state.stream = stream\n  state.socket = null\n  state.rawSocket = socket || stream.connection.socket\n  state.deceiver = null\n  state.ending = false\n\n  var self = this\n  thing.call(this, stream, {\n    getPeerName: function () {\n      return self._getPeerName()\n    },\n    close: function (callback) {\n      return self._closeCallback(callback)\n    }\n  })\n\n  if (!state.stream) {\n    this.on('stream', function (stream) {\n      state.stream = stream\n    })\n  }\n}\nutil.inherits(Handle, thing)\nmodule.exports = Handle\n\nHandle.create = function create (options, stream, socket) {\n  return new Handle(options, stream, socket)\n}\n\nHandle.prototype._getPeerName = function _getPeerName () {\n  var state = this._spdyState\n\n  if (state.rawSocket._getpeername) {\n    return state.rawSocket._getpeername()\n  }\n\n  return null\n}\n\nHandle.prototype._closeCallback = function _closeCallback (callback) {\n  var state = this._spdyState\n  var stream = state.stream\n\n  if (state.ending) {\n    // The .end() method of the stream may be called by us or by the\n    // .shutdown() method in our super-class. If the latter has already been\n    // called, then calling the .end() method below will have no effect, with\n    // the result that the callback will never get executed, leading to an ever\n    // so subtle memory leak.\n    if (stream._writableState.finished) {\n      // NOTE: it is important to call `setImmediate` instead of `nextTick`,\n      // since this is how regular `handle.close()` works in node.js core.\n      //\n      // Using `nextTick` will lead to `net.Socket` emitting `close` before\n      // `end` on UV_EOF. This results in aborted request without `end` event.\n      setImmediate(callback)\n    } else if (stream._writableState.ending) {\n      stream.once('finish', function () {\n        callback(null)\n      })\n    } else {\n      stream.end(callback)\n    }\n  } else {\n    stream.abort(callback)\n  }\n\n  // Only a single end is allowed\n  state.ending = false\n}\n\nHandle.prototype.getStream = function getStream (callback) {\n  var state = this._spdyState\n\n  if (!callback) {\n    assert(state.stream)\n    return state.stream\n  }\n\n  if (state.stream) {\n    process.nextTick(function () {\n      callback(state.stream)\n    })\n    return\n  }\n\n  this.on('stream', callback)\n}\n\nHandle.prototype.assignSocket = function assignSocket (socket, options) {\n  var state = this._spdyState\n\n  state.socket = socket\n  state.deceiver = httpDeceiver.create(socket, options)\n\n  function onStreamError (err) {\n    state.socket.emit('error', err)\n  }\n\n  this.getStream(function (stream) {\n    stream.on('error', onStreamError)\n  })\n}\n\nHandle.prototype.assignClientRequest = function assignClientRequest (req) {\n  var state = this._spdyState\n  var oldEnd = req.end\n  var oldSend = req._send\n\n  // Catch the headers before request will be sent\n  var self = this\n\n  // For old nodes\n  if (thing.mode !== 'modern') {\n    req.end = function end () {\n      this.end = oldEnd\n\n      this._send('')\n\n      return this.end.apply(this, arguments)\n    }\n  }\n\n  req._send = function send (data) {\n    this._headerSent = true\n\n    // for v0.10 and below, otherwise it will set `hot = false` and include\n    // headers in first write\n    this._header = 'ignore me'\n\n    // To prevent exception\n    this.connection = state.socket\n\n    // It is very important to leave this here, otherwise it will be executed\n    // on a next tick, after `_send` will perform write\n    self.getStream(function (stream) {\n      if (!stream.connection._isGoaway(stream.id)) {\n        stream.send()\n      }\n    })\n\n    // We are ready to create stream\n    self.emit('needStream')\n\n    // Ensure that the connection is still ok to use\n    if (state.stream && state.stream.connection._isGoaway(state.stream.id)) {\n      return\n    }\n\n    req._send = oldSend\n\n    // Ignore empty writes\n    if (req.method === 'GET' && data.length === 0) {\n      return\n    }\n\n    return req._send.apply(this, arguments)\n  }\n\n  // No chunked encoding\n  req.useChunkedEncodingByDefault = false\n\n  req.on('finish', function () {\n    req.socket.end()\n  })\n}\n\nHandle.prototype.assignRequest = function assignRequest (req) {\n  // Emit trailing headers\n  this.getStream(function (stream) {\n    stream.on('headers', function (headers) {\n      req.emit('trailers', headers)\n    })\n  })\n}\n\nHandle.prototype.assignResponse = function assignResponse (res) {\n  var self = this\n\n  res.addTrailers = function addTrailers (headers) {\n    self.getStream(function (stream) {\n      stream.sendHeaders(headers)\n    })\n  }\n}\n\nHandle.prototype._transformHeaders = function _transformHeaders (kind, headers) {\n  var state = this._spdyState\n\n  var res = {}\n  var keys = Object.keys(headers)\n\n  if (kind === 'request' && state.options['x-forwarded-for']) {\n    var xforwarded = state.stream.connection.getXForwardedFor()\n    if (xforwarded !== null) {\n      res['x-forwarded-for'] = xforwarded\n    }\n  }\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    var value = headers[key]\n\n    if (key === ':authority') {\n      res.host = value\n    }\n    if (/^:/.test(key)) {\n      continue\n    }\n\n    res[key] = value\n  }\n  return res\n}\n\nHandle.prototype.emitRequest = function emitRequest () {\n  var state = this._spdyState\n  var stream = state.stream\n\n  state.deceiver.emitRequest({\n    method: stream.method,\n    path: stream.path,\n    headers: this._transformHeaders('request', stream.headers)\n  })\n}\n\nHandle.prototype.emitResponse = function emitResponse (status, headers) {\n  var state = this._spdyState\n\n  state.deceiver.emitResponse({\n    status: status,\n    headers: this._transformHeaders('response', headers)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}