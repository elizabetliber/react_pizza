{"ast":null,"code":"'use strict';\n\nvar transport = require('../../../spdy-transport');\n\nvar util = require('util');\n\nvar utils = require('./').utils;\n\nvar OffsetBuffer = require('obuf');\n\nvar Transform = require('readable-stream').Transform;\n\nfunction Parser(options) {\n  Transform.call(this, {\n    readableObjectMode: true\n  });\n  this.buffer = new OffsetBuffer();\n  this.partial = false;\n  this.waiting = 0;\n  this.window = options.window;\n  this.version = null;\n  this.decompress = null;\n  this.dead = false;\n}\n\nmodule.exports = Parser;\nutil.inherits(Parser, Transform);\nParser.prototype.error = utils.error;\n\nParser.prototype.kill = function kill() {\n  this.dead = true;\n};\n\nParser.prototype._transform = function transform(data, encoding, cb) {\n  if (!this.dead) {\n    this.buffer.push(data);\n  }\n\n  this._consume(cb);\n};\n\nParser.prototype._consume = function _consume(cb) {\n  var self = this;\n\n  function next(err, frame) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (Array.isArray(frame)) {\n      for (var i = 0; i < frame.length; i++) {\n        self.push(frame[i]);\n      }\n    } else if (frame) {\n      self.push(frame);\n    } // Consume more packets\n\n\n    if (!sync) {\n      return self._consume(cb);\n    }\n\n    process.nextTick(function () {\n      self._consume(cb);\n    });\n  }\n\n  if (this.dead) {\n    return cb();\n  }\n\n  if (this.buffer.size < this.waiting) {\n    // No data at all\n    if (this.buffer.size === 0) {\n      return cb();\n    } // Partial DATA frame or something that we can process partially\n\n\n    if (this.partial) {\n      var partial = this.buffer.clone(this.buffer.size);\n      this.buffer.skip(partial.size);\n      this.waiting -= partial.size;\n      this.executePartial(partial, next);\n      return;\n    } // We shall not do anything until we get all expected data\n\n\n    return cb();\n  }\n\n  var sync = true;\n  var content = this.buffer.clone(this.waiting);\n  this.buffer.skip(this.waiting);\n  this.execute(content, next);\n  sync = false;\n};\n\nParser.prototype.setVersion = function setVersion(version) {\n  this.version = version;\n  this.emit('version', version);\n};\n\nParser.prototype.setCompression = function setCompresion(pair) {\n  this.decompress = new transport.utils.LockStream(pair.decompress);\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/spdy-transport/lib/spdy-transport/protocol/base/parser.js"],"names":["transport","require","util","utils","OffsetBuffer","Transform","Parser","options","call","readableObjectMode","buffer","partial","waiting","window","version","decompress","dead","module","exports","inherits","prototype","error","kill","_transform","transform","data","encoding","cb","push","_consume","self","next","err","frame","Array","isArray","i","length","sync","process","nextTick","size","clone","skip","executePartial","content","execute","setVersion","emit","setCompression","setCompresion","pair","LockStream"],"mappings":"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","sourcesContent":["'use strict'\n\nvar transport = require('../../../spdy-transport')\n\nvar util = require('util')\nvar utils = require('./').utils\nvar OffsetBuffer = require('obuf')\nvar Transform = require('readable-stream').Transform\n\nfunction Parser (options) {\n  Transform.call(this, {\n    readableObjectMode: true\n  })\n\n  this.buffer = new OffsetBuffer()\n  this.partial = false\n  this.waiting = 0\n\n  this.window = options.window\n\n  this.version = null\n  this.decompress = null\n  this.dead = false\n}\nmodule.exports = Parser\nutil.inherits(Parser, Transform)\n\nParser.prototype.error = utils.error\n\nParser.prototype.kill = function kill () {\n  this.dead = true\n}\n\nParser.prototype._transform = function transform (data, encoding, cb) {\n  if (!this.dead) { this.buffer.push(data) }\n\n  this._consume(cb)\n}\n\nParser.prototype._consume = function _consume (cb) {\n  var self = this\n\n  function next (err, frame) {\n    if (err) {\n      return cb(err)\n    }\n\n    if (Array.isArray(frame)) {\n      for (var i = 0; i < frame.length; i++) {\n        self.push(frame[i])\n      }\n    } else if (frame) {\n      self.push(frame)\n    }\n\n    // Consume more packets\n    if (!sync) {\n      return self._consume(cb)\n    }\n\n    process.nextTick(function () {\n      self._consume(cb)\n    })\n  }\n\n  if (this.dead) {\n    return cb()\n  }\n\n  if (this.buffer.size < this.waiting) {\n    // No data at all\n    if (this.buffer.size === 0) {\n      return cb()\n    }\n\n    // Partial DATA frame or something that we can process partially\n    if (this.partial) {\n      var partial = this.buffer.clone(this.buffer.size)\n      this.buffer.skip(partial.size)\n      this.waiting -= partial.size\n\n      this.executePartial(partial, next)\n      return\n    }\n\n    // We shall not do anything until we get all expected data\n    return cb()\n  }\n\n  var sync = true\n\n  var content = this.buffer.clone(this.waiting)\n  this.buffer.skip(this.waiting)\n\n  this.execute(content, next)\n  sync = false\n}\n\nParser.prototype.setVersion = function setVersion (version) {\n  this.version = version\n  this.emit('version', version)\n}\n\nParser.prototype.setCompression = function setCompresion (pair) {\n  this.decompress = new transport.utils.LockStream(pair.decompress)\n}\n"]},"metadata":{},"sourceType":"script"}