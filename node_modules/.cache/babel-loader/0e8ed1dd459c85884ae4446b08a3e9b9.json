{"ast":null,"code":"module.exports = function bufferIndexOf(buff, search, offset, encoding) {\n  if (!Buffer.isBuffer(buff)) {\n    throw TypeError('buffer is not a buffer');\n  } // allow optional offset when providing an encoding\n\n\n  if (encoding === undefined && typeof offset === 'string') {\n    encoding = offset;\n    offset = undefined;\n  }\n\n  if (typeof search === 'string') {\n    search = new Buffer(search, encoding || 'utf8');\n  } else if (typeof search === 'number' && !isNaN(search)) {\n    search = new Buffer([search]);\n  } else if (!Buffer.isBuffer(search)) {\n    throw TypeError('search is not a bufferable object');\n  }\n\n  if (search.length === 0) {\n    return -1;\n  }\n\n  if (offset === undefined || typeof offset === 'number' && isNaN(offset)) {\n    offset = 0;\n  } else if (typeof offset !== 'number') {\n    throw TypeError('offset is not a number');\n  }\n\n  if (offset < 0) {\n    offset = buff.length + offset;\n  }\n\n  if (offset < 0) {\n    offset = 0;\n  }\n\n  var m = 0;\n  var s = -1;\n\n  for (var i = offset; i < buff.length; ++i) {\n    if (buff[i] != search[m]) {\n      s = -1; // <-- go back\n      // match abc to aabc\n      // 'aabc'\n      // 'aab'\n      //    ^ no match\n      // a'abc'\n      //   ^ set index here now and look at these again.\n      //   'abc' yay!\n\n      i -= m - 1;\n      m = 0;\n    }\n\n    if (buff[i] == search[m]) {\n      if (s == -1) {\n        s = i;\n      }\n\n      ++m;\n\n      if (m == search.length) {\n        break;\n      }\n    }\n  }\n\n  if (s > -1 && buff.length - s < search.length) {\n    return -1;\n  }\n\n  return s;\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/buffer-indexof/index.js"],"names":["module","exports","bufferIndexOf","buff","search","offset","encoding","Buffer","isBuffer","TypeError","undefined","isNaN","length","m","s","i"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,MAA7B,EAAqCC,MAArC,EAA6CC,QAA7C,EAAsD;AACrE,MAAI,CAACC,MAAM,CAACC,QAAP,CAAgBL,IAAhB,CAAL,EAA4B;AAC1B,UAAMM,SAAS,CAAC,wBAAD,CAAf;AACD,GAHoE,CAKrE;;;AACA,MAAIH,QAAQ,KAAKI,SAAb,IAA0B,OAAOL,MAAP,KAAkB,QAAhD,EAA0D;AACxDC,IAAAA,QAAQ,GAAGD,MAAX;AACAA,IAAAA,MAAM,GAAGK,SAAT;AACD;;AAED,MAAI,OAAON,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,IAAAA,MAAM,GAAG,IAAIG,MAAJ,CAAWH,MAAX,EAAmBE,QAAQ,IAAI,MAA/B,CAAT;AACD,GAFD,MAEO,IAAI,OAAOF,MAAP,KAAkB,QAAlB,IAA8B,CAACO,KAAK,CAACP,MAAD,CAAxC,EAAkD;AACvDA,IAAAA,MAAM,GAAG,IAAIG,MAAJ,CAAW,CAACH,MAAD,CAAX,CAAT;AACD,GAFM,MAEA,IAAI,CAACG,MAAM,CAACC,QAAP,CAAgBJ,MAAhB,CAAL,EAA8B;AACnC,UAAMK,SAAS,CAAC,mCAAD,CAAf;AACD;;AAED,MAAIL,MAAM,CAACQ,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO,CAAC,CAAR;AACD;;AAED,MAAIP,MAAM,KAAKK,SAAX,IAAyB,OAAOL,MAAP,KAAkB,QAAlB,IAA8BM,KAAK,CAACN,MAAD,CAAhE,EAA2E;AACzEA,IAAAA,MAAM,GAAG,CAAT;AACD,GAFD,MAEO,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AACrC,UAAMI,SAAS,CAAC,wBAAD,CAAf;AACD;;AAED,MAAIJ,MAAM,GAAG,CAAb,EAAgB;AACdA,IAAAA,MAAM,GAAGF,IAAI,CAACS,MAAL,GAAcP,MAAvB;AACD;;AAED,MAAIA,MAAM,GAAG,CAAb,EAAgB;AACdA,IAAAA,MAAM,GAAG,CAAT;AACD;;AAED,MAAIQ,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAC,CAAT;;AAEA,OAAK,IAAIC,CAAC,GAAGV,MAAb,EAAqBU,CAAC,GAAGZ,IAAI,CAACS,MAA9B,EAAuC,EAAEG,CAAzC,EAA4C;AAC1C,QAAGZ,IAAI,CAACY,CAAD,CAAJ,IAAWX,MAAM,CAACS,CAAD,CAApB,EAAwB;AACtBC,MAAAA,CAAC,GAAG,CAAC,CAAL,CADsB,CAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAC,MAAAA,CAAC,IAAIF,CAAC,GAAC,CAAP;AACAA,MAAAA,CAAC,GAAG,CAAJ;AACD;;AAED,QAAGV,IAAI,CAACY,CAAD,CAAJ,IAAWX,MAAM,CAACS,CAAD,CAApB,EAAyB;AACvB,UAAGC,CAAC,IAAI,CAAC,CAAT,EAAY;AACVA,QAAAA,CAAC,GAAGC,CAAJ;AACD;;AACD,QAAEF,CAAF;;AACA,UAAGA,CAAC,IAAIT,MAAM,CAACQ,MAAf,EAAuB;AACrB;AACD;AACF;AACF;;AAED,MAAIE,CAAC,GAAG,CAAC,CAAL,IAAUX,IAAI,CAACS,MAAL,GAAcE,CAAd,GAAkBV,MAAM,CAACQ,MAAvC,EAA+C;AAC7C,WAAO,CAAC,CAAR;AACD;;AACD,SAAOE,CAAP;AACD,CAtED","sourcesContent":["module.exports = function bufferIndexOf(buff, search, offset, encoding){\n  if (!Buffer.isBuffer(buff)) {\n    throw TypeError('buffer is not a buffer');\n  }\n\n  // allow optional offset when providing an encoding\n  if (encoding === undefined && typeof offset === 'string') {\n    encoding = offset;\n    offset = undefined;\n  }\n\n  if (typeof search === 'string') {\n    search = new Buffer(search, encoding || 'utf8');\n  } else if (typeof search === 'number' && !isNaN(search)) {\n    search = new Buffer([search])\n  } else if (!Buffer.isBuffer(search)) {\n    throw TypeError('search is not a bufferable object');\n  }\n\n  if (search.length === 0) {\n    return -1;\n  }\n\n  if (offset === undefined || (typeof offset === 'number' && isNaN(offset))) {\n    offset = 0;\n  } else if (typeof offset !== 'number') {\n    throw TypeError('offset is not a number');\n  }\n\n  if (offset < 0) {\n    offset = buff.length + offset\n  }\n\n  if (offset < 0) {\n    offset = 0;\n  }\n\n  var m = 0;\n  var s = -1;\n\n  for (var i = offset; i < buff.length ; ++i) {\n    if(buff[i] != search[m]){\n      s = -1;\n      // <-- go back\n      // match abc to aabc\n      // 'aabc'\n      // 'aab'\n      //    ^ no match\n      // a'abc'\n      //   ^ set index here now and look at these again.\n      //   'abc' yay!\n      i -= m-1\n      m = 0;\n    }\n\n    if(buff[i] == search[m]) {\n      if(s == -1) {\n        s = i;\n      }\n      ++m;\n      if(m == search.length) {\n        break;\n      }\n    }\n  }\n\n  if (s > -1 && buff.length - s < search.length) {\n    return -1;\n  }\n  return s;\n}\n\n\n"]},"metadata":{},"sourceType":"script"}