{"ast":null,"code":"var assert = require('minimalistic-assert');\n\nvar Buffer = require('buffer').Buffer;\n\nfunction WBuf() {\n  this.buffers = [];\n  this.toReserve = 0;\n  this.size = 0;\n  this.maxSize = 0;\n  this.avail = 0;\n  this.last = null;\n  this.offset = 0; // Used in slicing\n\n  this.sliceQueue = null;\n  this.forceReserve = false; // Mostly a constant\n\n  this.reserveRate = 64;\n}\n\nmodule.exports = WBuf;\n\nWBuf.prototype.reserve = function reserve(n) {\n  this.toReserve += n; // Force reservation of extra bytes\n\n  if (this.forceReserve) this.toReserve = Math.max(this.toReserve, this.reserveRate);\n};\n\nWBuf.prototype._ensure = function _ensure(n) {\n  if (this.avail >= n) return;\n  if (this.toReserve === 0) this.toReserve = this.reserveRate;\n  this.toReserve = Math.max(n - this.avail, this.toReserve);\n  if (this.avail === 0) this._next();\n};\n\nWBuf.prototype._next = function _next() {\n  var buf;\n\n  if (this.sliceQueue === null) {\n    // Most common case\n    buf = new Buffer(this.toReserve);\n  } else {\n    // Only for `.slice()` results\n    buf = this.sliceQueue.shift();\n    if (this.sliceQueue.length === 0) this.sliceQueue = null;\n  }\n\n  this.toReserve = 0;\n  this.buffers.push(buf);\n  this.avail = buf.length;\n  this.offset = 0;\n  this.last = buf;\n};\n\nWBuf.prototype._rangeCheck = function _rangeCheck() {\n  if (this.maxSize !== 0 && this.size > this.maxSize) throw new RangeError('WBuf overflow');\n};\n\nWBuf.prototype._move = function _move(n) {\n  this.size += n;\n  if (this.avail === 0) this.last = null;\n\n  this._rangeCheck();\n};\n\nWBuf.prototype.slice = function slice(start, end) {\n  assert(0 <= start && start <= this.size);\n  assert(0 <= end && end <= this.size);\n  if (this.last === null) this._next();\n  var res = new WBuf(); // Only last chunk is requested\n\n  if (start >= this.size - this.offset) {\n    res.buffers.push(this.last);\n    res.last = this.last;\n    res.offset = start - this.size + this.offset;\n    res.maxSize = end - start;\n    res.avail = res.maxSize;\n    return res;\n  }\n\n  var startIndex = -1;\n  var startOffset = 0;\n  var endIndex = -1; // Find buffer indices\n\n  var offset = 0;\n\n  for (var i = 0; i < this.buffers.length; i++) {\n    var buf = this.buffers[i];\n    var next = offset + buf.length; // Found the start\n\n    if (start >= offset && start <= next) {\n      startIndex = i;\n      startOffset = start - offset;\n      if (endIndex !== -1) break;\n    }\n\n    if (end >= offset && end <= next) {\n      endIndex = i;\n      if (startIndex !== -1) break;\n    }\n\n    offset = next;\n  }\n\n  res.last = this.buffers[startIndex];\n  res.offset = startOffset;\n  res.maxSize = end - start; // Multi-buffer slice\n\n  if (startIndex < endIndex) {\n    res.sliceQueue = this.buffers.slice(startIndex + 1, endIndex + 1);\n    res.last = res.last.slice(res.offset);\n    res.offset = 0;\n  }\n\n  res.avail = res.last.length - res.offset;\n  res.buffers.push(res.last);\n  return res;\n};\n\nWBuf.prototype.skip = function skip(n) {\n  if (n === 0) return this.slice(this.size, this.size);\n\n  this._ensure(n);\n\n  var left = n;\n\n  while (left > 0) {\n    var toSkip = Math.min(left, this.avail);\n    left -= toSkip;\n    this.size += toSkip;\n\n    if (toSkip === this.avail) {\n      if (left !== 0) {\n        this._next();\n      } else {\n        this.avail -= toSkip;\n        this.offset += toSkip;\n      }\n    } else {\n      this.offset += toSkip;\n      this.avail -= toSkip;\n    }\n  }\n\n  this._rangeCheck();\n\n  return this.slice(this.size - n, this.size);\n};\n\nWBuf.prototype.write = function write(str) {\n  var len = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c > 255) len += 2;else len += 1;\n  }\n\n  this.reserve(len);\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    var hi = c >>> 8;\n    var lo = c & 0xff;\n    if (hi) this.writeUInt8(hi);\n    this.writeUInt8(lo);\n  }\n};\n\nWBuf.prototype.copyFrom = function copyFrom(buf, start, end) {\n  var off = start === undefined ? 0 : start;\n  var len = end === undefined ? buf.length : end;\n  if (off === len) return;\n\n  this._ensure(len - off);\n\n  while (off < len) {\n    var toCopy = Math.min(len - off, this.avail);\n    buf.copy(this.last, this.offset, off, off + toCopy);\n    off += toCopy;\n    this.size += toCopy;\n\n    if (toCopy === this.avail) {\n      if (off !== len) {\n        this._next();\n      } else {\n        this.avail = 0;\n        this.offset += toCopy;\n      }\n    } else {\n      this.offset += toCopy;\n      this.avail -= toCopy;\n    }\n  }\n\n  this._rangeCheck();\n};\n\nWBuf.prototype.writeUInt8 = function writeUInt8(v) {\n  this._ensure(1);\n\n  this.last[this.offset++] = v;\n  this.avail--;\n\n  this._move(1);\n};\n\nWBuf.prototype.writeUInt16BE = function writeUInt16BE(v) {\n  this._ensure(2); // Fast case - everything fits into the last buffer\n\n\n  if (this.avail >= 2) {\n    this.last.writeUInt16BE(v, this.offset);\n    this.offset += 2;\n    this.avail -= 2; // One byte here, one byte there\n  } else {\n    this.last[this.offset] = v >>> 8;\n\n    this._next();\n\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n  }\n\n  this._move(2);\n};\n\nWBuf.prototype.writeUInt24BE = function writeUInt24BE(v) {\n  this._ensure(3); // Fast case - everything fits into the last buffer\n\n\n  if (this.avail >= 3) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n    this.last[this.offset + 2] = v & 0xff;\n    this.offset += 3;\n    this.avail -= 3;\n\n    this._move(3); // Two bytes here\n\n  } else if (this.avail >= 2) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n\n    this._next();\n\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n\n    this._move(3); // Just one byte here\n\n  } else {\n    this.last[this.offset] = v >>> 16;\n\n    this._move(1);\n\n    this._next();\n\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\n\nWBuf.prototype.writeUInt32BE = function writeUInt32BE(v) {\n  this._ensure(4); // Fast case - everything fits into the last buffer\n\n\n  if (this.avail >= 4) {\n    this.last.writeUInt32BE(v, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n\n    this._move(4); // Three bytes here\n\n  } else if (this.avail >= 3) {\n    this.writeUInt24BE(v >>> 8);\n\n    this._next();\n\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n\n    this._move(1); // Slow case, who cares\n\n  } else {\n    this.writeUInt16BE(v >>> 16);\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\n\nWBuf.prototype.writeUInt16LE = function writeUInt16LE(num) {\n  var r = (num & 0xff) << 8 | num >>> 8;\n  this.writeUInt16BE(r);\n};\n\nWBuf.prototype.writeUInt24LE = function writeUInt24LE(num) {\n  var r = (num & 0xff) << 16 | (num >>> 8 & 0xff) << 8 | num >>> 16;\n  this.writeUInt24BE(r);\n};\n\nWBuf.prototype.writeUInt32LE = function writeUInt32LE(num) {\n  this._ensure(4); // Fast case - everything fits into the last buffer\n\n\n  if (this.avail >= 4) {\n    this.last.writeUInt32LE(num, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n\n    this._move(4); // Three bytes here\n\n  } else if (this.avail >= 3) {\n    this.writeUInt24LE(num & 0xffffff);\n\n    this._next();\n\n    this.last[this.offset++] = num >>> 24;\n    this.avail--;\n\n    this._move(1); // Slow case, who cares\n\n  } else {\n    this.writeUInt16LE(num & 0xffff);\n    this.writeUInt16LE(num >>> 16);\n  }\n};\n\nWBuf.prototype.render = function render() {\n  var left = this.size;\n  var out = [];\n\n  for (var i = 0; i < this.buffers.length && left >= 0; i++) {\n    var buf = this.buffers[i];\n    left -= buf.length;\n\n    if (left >= 0) {\n      out.push(buf);\n    } else {\n      out.push(buf.slice(0, buf.length + left));\n    }\n  }\n\n  return out;\n}; // Signed APIs\n\n\nWBuf.prototype.writeInt8 = function writeInt8(num) {\n  if (num < 0) return this.writeUInt8(0x100 + num);else return this.writeUInt8(num);\n};\n\nfunction toUnsigned16(num) {\n  if (num < 0) return 0x10000 + num;else return num;\n}\n\nWBuf.prototype.writeInt16LE = function writeInt16LE(num) {\n  this.writeUInt16LE(toUnsigned16(num));\n};\n\nWBuf.prototype.writeInt16BE = function writeInt16BE(num) {\n  this.writeUInt16BE(toUnsigned16(num));\n};\n\nfunction toUnsigned24(num) {\n  if (num < 0) return 0x1000000 + num;else return num;\n}\n\nWBuf.prototype.writeInt24LE = function writeInt24LE(num) {\n  this.writeUInt24LE(toUnsigned24(num));\n};\n\nWBuf.prototype.writeInt24BE = function writeInt24BE(num) {\n  this.writeUInt24BE(toUnsigned24(num));\n};\n\nfunction toUnsigned32(num) {\n  if (num < 0) return 0xffffffff + num + 1;else return num;\n}\n\nWBuf.prototype.writeInt32LE = function writeInt32LE(num) {\n  this.writeUInt32LE(toUnsigned32(num));\n};\n\nWBuf.prototype.writeInt32BE = function writeInt32BE(num) {\n  this.writeUInt32BE(toUnsigned32(num));\n};\n\nWBuf.prototype.writeComb = function writeComb(size, endian, value) {\n  if (size === 1) return this.writeUInt8(value);\n\n  if (endian === 'le') {\n    if (size === 2) this.writeUInt16LE(value);else if (size === 3) this.writeUInt24LE(value);else if (size === 4) this.writeUInt32LE(value);\n  } else {\n    if (size === 2) this.writeUInt16BE(value);else if (size === 3) this.writeUInt24BE(value);else if (size === 4) this.writeUInt32BE(value);\n  }\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/wbuf/index.js"],"names":["assert","require","Buffer","WBuf","buffers","toReserve","size","maxSize","avail","last","offset","sliceQueue","forceReserve","reserveRate","module","exports","prototype","reserve","n","Math","max","_ensure","_next","buf","shift","length","push","_rangeCheck","RangeError","_move","slice","start","end","res","startIndex","startOffset","endIndex","i","next","skip","left","toSkip","min","write","str","len","c","charCodeAt","hi","lo","writeUInt8","copyFrom","off","undefined","toCopy","copy","v","writeUInt16BE","writeUInt24BE","writeUInt32BE","writeUInt16LE","num","r","writeUInt24LE","writeUInt32LE","render","out","writeInt8","toUnsigned16","writeInt16LE","writeInt16BE","toUnsigned24","writeInt24LE","writeInt24BE","toUnsigned32","writeInt32LE","writeInt32BE","writeComb","endian","value"],"mappings":"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","sourcesContent":["var assert = require('minimalistic-assert');\nvar Buffer = require('buffer').Buffer;\n\nfunction WBuf() {\n  this.buffers = [];\n  this.toReserve = 0;\n  this.size = 0;\n  this.maxSize = 0;\n  this.avail = 0;\n\n  this.last = null;\n  this.offset = 0;\n\n  // Used in slicing\n  this.sliceQueue = null;\n\n  this.forceReserve = false;\n\n  // Mostly a constant\n  this.reserveRate = 64;\n}\nmodule.exports = WBuf;\n\nWBuf.prototype.reserve = function reserve(n) {\n  this.toReserve += n;\n\n  // Force reservation of extra bytes\n  if (this.forceReserve)\n    this.toReserve = Math.max(this.toReserve, this.reserveRate);\n};\n\nWBuf.prototype._ensure = function _ensure(n) {\n  if (this.avail >= n)\n    return;\n\n  if (this.toReserve === 0)\n    this.toReserve = this.reserveRate;\n\n  this.toReserve = Math.max(n - this.avail, this.toReserve);\n\n  if (this.avail === 0)\n    this._next();\n};\n\nWBuf.prototype._next = function _next() {\n  var buf;\n  if (this.sliceQueue === null) {\n    // Most common case\n    buf = new Buffer(this.toReserve);\n  } else {\n    // Only for `.slice()` results\n    buf = this.sliceQueue.shift();\n    if (this.sliceQueue.length === 0)\n      this.sliceQueue = null;\n  }\n\n  this.toReserve = 0;\n\n  this.buffers.push(buf);\n  this.avail = buf.length;\n  this.offset = 0;\n  this.last = buf;\n};\n\nWBuf.prototype._rangeCheck = function _rangeCheck() {\n  if (this.maxSize !== 0 && this.size > this.maxSize)\n    throw new RangeError('WBuf overflow');\n};\n\nWBuf.prototype._move = function _move(n) {\n  this.size += n;\n  if (this.avail === 0)\n    this.last = null;\n\n  this._rangeCheck();\n};\n\nWBuf.prototype.slice = function slice(start, end) {\n  assert(0 <= start && start <= this.size);\n  assert(0 <= end && end <= this.size);\n\n  if (this.last === null)\n    this._next();\n\n  var res = new WBuf();\n\n  // Only last chunk is requested\n  if (start >= this.size - this.offset) {\n    res.buffers.push(this.last);\n    res.last = this.last;\n    res.offset = start - this.size + this.offset;\n    res.maxSize = end - start;\n    res.avail = res.maxSize;\n\n    return res;\n  }\n\n  var startIndex = -1;\n  var startOffset = 0;\n  var endIndex = -1;\n\n  // Find buffer indices\n  var offset = 0;\n  for (var i = 0; i < this.buffers.length; i++) {\n    var buf = this.buffers[i];\n    var next = offset + buf.length;\n\n    // Found the start\n    if (start >= offset && start <= next) {\n      startIndex = i;\n      startOffset = start - offset;\n      if (endIndex !== -1)\n        break;\n    }\n    if (end >= offset && end <= next) {\n      endIndex = i;\n      if (startIndex !== -1)\n        break;\n    }\n\n    offset = next;\n  }\n\n  res.last = this.buffers[startIndex];\n  res.offset = startOffset;\n  res.maxSize = end - start;\n\n  // Multi-buffer slice\n  if (startIndex < endIndex) {\n    res.sliceQueue = this.buffers.slice(startIndex + 1, endIndex + 1);\n\n    res.last = res.last.slice(res.offset);\n    res.offset = 0;\n  }\n\n  res.avail = res.last.length - res.offset;\n  res.buffers.push(res.last);\n\n  return res;\n};\n\nWBuf.prototype.skip = function skip(n) {\n  if (n === 0)\n    return this.slice(this.size, this.size);\n\n  this._ensure(n);\n\n  var left = n;\n  while (left > 0) {\n    var toSkip = Math.min(left, this.avail);\n    left -= toSkip;\n    this.size += toSkip;\n    if (toSkip === this.avail) {\n      if (left !== 0) {\n        this._next();\n      } else {\n        this.avail -= toSkip;\n        this.offset += toSkip;\n      }\n    } else {\n      this.offset += toSkip;\n      this.avail -= toSkip;\n    }\n  }\n\n  this._rangeCheck();\n\n  return this.slice(this.size - n, this.size);\n};\n\nWBuf.prototype.write = function write(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c > 255)\n      len += 2;\n    else\n      len += 1;\n  }\n  this.reserve(len);\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    var hi = c >>> 8;\n    var lo = c & 0xff;\n\n    if (hi)\n      this.writeUInt8(hi);\n    this.writeUInt8(lo);\n  }\n};\n\nWBuf.prototype.copyFrom = function copyFrom(buf, start, end) {\n  var off = start === undefined ? 0 : start;\n  var len = end === undefined ? buf.length : end;\n  if (off === len)\n    return;\n\n  this._ensure(len - off);\n  while (off < len) {\n    var toCopy = Math.min(len - off, this.avail);\n    buf.copy(this.last, this.offset, off, off + toCopy);\n    off += toCopy;\n    this.size += toCopy;\n    if (toCopy === this.avail) {\n      if (off !== len) {\n        this._next();\n      } else {\n        this.avail = 0;\n        this.offset += toCopy;\n      }\n    } else {\n      this.offset += toCopy;\n      this.avail -= toCopy;\n    }\n  }\n\n  this._rangeCheck();\n};\n\nWBuf.prototype.writeUInt8 = function writeUInt8(v) {\n  this._ensure(1);\n\n  this.last[this.offset++] = v;\n  this.avail--;\n  this._move(1);\n};\n\nWBuf.prototype.writeUInt16BE = function writeUInt16BE(v) {\n  this._ensure(2);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 2) {\n    this.last.writeUInt16BE(v, this.offset);\n    this.offset += 2;\n    this.avail -= 2;\n\n  // One byte here, one byte there\n  } else {\n    this.last[this.offset] = (v >>> 8);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n  }\n\n  this._move(2);\n};\n\nWBuf.prototype.writeUInt24BE = function writeUInt24BE(v) {\n  this._ensure(3);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 3) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n    this.last[this.offset + 2] = v & 0xff;\n    this.offset += 3;\n    this.avail -= 3;\n    this._move(3);\n\n  // Two bytes here\n  } else if (this.avail >= 2) {\n    this.last.writeUInt16BE(v >>> 8, this.offset);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n    this._move(3);\n\n  // Just one byte here\n  } else {\n    this.last[this.offset] = v >>> 16;\n    this._move(1);\n    this._next();\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\n\nWBuf.prototype.writeUInt32BE = function writeUInt32BE(v) {\n  this._ensure(4);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 4) {\n    this.last.writeUInt32BE(v, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n    this._move(4);\n\n  // Three bytes here\n  } else if (this.avail >= 3) {\n    this.writeUInt24BE(v >>> 8);\n    this._next();\n    this.last[this.offset++] = v & 0xff;\n    this.avail--;\n    this._move(1);\n\n  // Slow case, who cares\n  } else {\n    this.writeUInt16BE(v >>> 16);\n    this.writeUInt16BE(v & 0xffff);\n  }\n};\n\nWBuf.prototype.writeUInt16LE = function writeUInt16LE(num) {\n  var r = ((num & 0xff) << 8) | (num >>> 8);\n  this.writeUInt16BE(r);\n};\n\nWBuf.prototype.writeUInt24LE = function writeUInt24LE(num) {\n  var r = ((num & 0xff) << 16) | (((num >>> 8) & 0xff) << 8) | (num >>> 16);\n  this.writeUInt24BE(r);\n};\n\nWBuf.prototype.writeUInt32LE = function writeUInt32LE(num) {\n  this._ensure(4);\n\n  // Fast case - everything fits into the last buffer\n  if (this.avail >= 4) {\n    this.last.writeUInt32LE(num, this.offset);\n    this.offset += 4;\n    this.avail -= 4;\n    this._move(4);\n\n  // Three bytes here\n  } else if (this.avail >= 3) {\n    this.writeUInt24LE(num & 0xffffff);\n    this._next();\n    this.last[this.offset++] = num >>> 24;\n    this.avail--;\n    this._move(1);\n\n  // Slow case, who cares\n  } else {\n    this.writeUInt16LE(num & 0xffff);\n    this.writeUInt16LE(num >>> 16);\n  }\n};\n\nWBuf.prototype.render = function render() {\n  var left = this.size;\n  var out = [];\n\n  for (var i = 0; i < this.buffers.length && left >= 0; i++) {\n    var buf = this.buffers[i];\n    left -= buf.length;\n    if (left >= 0) {\n      out.push(buf);\n    } else {\n      out.push(buf.slice(0, buf.length + left));\n    }\n  }\n\n  return out;\n};\n\n// Signed APIs\nWBuf.prototype.writeInt8 = function writeInt8(num) {\n  if (num < 0)\n    return this.writeUInt8(0x100 + num);\n  else\n    return this.writeUInt8(num);\n};\n\nfunction toUnsigned16(num) {\n  if (num < 0)\n    return 0x10000 + num;\n  else\n    return num;\n}\n\nWBuf.prototype.writeInt16LE = function writeInt16LE(num) {\n  this.writeUInt16LE(toUnsigned16(num));\n};\n\nWBuf.prototype.writeInt16BE = function writeInt16BE(num) {\n  this.writeUInt16BE(toUnsigned16(num));\n};\n\nfunction toUnsigned24(num) {\n  if (num < 0)\n    return 0x1000000 + num;\n  else\n    return num;\n}\n\nWBuf.prototype.writeInt24LE = function writeInt24LE(num) {\n  this.writeUInt24LE(toUnsigned24(num));\n};\n\nWBuf.prototype.writeInt24BE = function writeInt24BE(num) {\n  this.writeUInt24BE(toUnsigned24(num));\n};\n\nfunction toUnsigned32(num) {\n  if (num < 0)\n    return (0xffffffff + num) + 1;\n  else\n    return num;\n}\n\nWBuf.prototype.writeInt32LE = function writeInt32LE(num) {\n  this.writeUInt32LE(toUnsigned32(num));\n};\n\nWBuf.prototype.writeInt32BE = function writeInt32BE(num) {\n  this.writeUInt32BE(toUnsigned32(num));\n};\n\nWBuf.prototype.writeComb = function writeComb(size, endian, value) {\n  if (size === 1)\n    return this.writeUInt8(value);\n\n  if (endian === 'le') {\n    if (size === 2)\n      this.writeUInt16LE(value);\n    else if (size === 3)\n      this.writeUInt24LE(value);\n    else if (size === 4)\n      this.writeUInt32LE(value);\n  } else {\n    if (size === 2)\n      this.writeUInt16BE(value);\n    else if (size === 3)\n      this.writeUInt24BE(value);\n    else if (size === 4)\n      this.writeUInt32BE(value);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}