{"ast":null,"code":"var forge = require('node-forge'); // a hexString is considered negative if it's most significant bit is 1\n// because serial numbers use ones' complement notation\n// this RFC in section 4.1.2.2 requires serial numbers to be positive\n// http://www.ietf.org/rfc/rfc5280.txt\n\n\nfunction toPositiveHex(hexString) {\n  var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);\n\n  if (mostSiginficativeHexAsInt < 8) {\n    return hexString;\n  }\n\n  mostSiginficativeHexAsInt -= 8;\n  return mostSiginficativeHexAsInt.toString() + hexString.substring(1);\n}\n\nfunction getAlgorithm(key) {\n  switch (key) {\n    case 'sha256':\n      return forge.md.sha256.create();\n\n    default:\n      return forge.md.sha1.create();\n  }\n}\n\nexports.generate = function generate(attrs, options, done) {\n  if (typeof attrs === 'function') {\n    done = attrs;\n    attrs = undefined;\n  } else if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var generatePem = function (keyPair) {\n    var cert = forge.pki.createCertificate();\n    cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9))); // the serial number can be decimal or hex (if preceded by 0x)\n\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options.days || 365));\n    attrs = attrs || [{\n      name: 'commonName',\n      value: 'example.org'\n    }, {\n      name: 'countryName',\n      value: 'US'\n    }, {\n      shortName: 'ST',\n      value: 'Virginia'\n    }, {\n      name: 'localityName',\n      value: 'Blacksburg'\n    }, {\n      name: 'organizationName',\n      value: 'Test'\n    }, {\n      shortName: 'OU',\n      value: 'Test'\n    }];\n    cert.setSubject(attrs);\n    cert.setIssuer(attrs);\n    cert.publicKey = keyPair.publicKey;\n    cert.setExtensions(options.extensions || [{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'subjectAltName',\n      altNames: [{\n        type: 6,\n        // URI\n        value: 'http://example.org/webid#me'\n      }]\n    }]);\n    cert.sign(keyPair.privateKey, getAlgorithm(options && options.algorithm));\n    const fingerprint = forge.md.sha1.create().update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes()).digest().toHex().match(/.{2}/g).join(':');\n    var pem = {\n      private: forge.pki.privateKeyToPem(keyPair.privateKey),\n      public: forge.pki.publicKeyToPem(keyPair.publicKey),\n      cert: forge.pki.certificateToPem(cert),\n      fingerprint: fingerprint\n    };\n\n    if (options && options.pkcs7) {\n      var p7 = forge.pkcs7.createSignedData();\n      p7.addCertificate(cert);\n      pem.pkcs7 = forge.pkcs7.messageToPem(p7);\n    }\n\n    if (options && options.clientCertificate) {\n      var clientkeys = forge.pki.rsa.generateKeyPair(1024);\n      var clientcert = forge.pki.createCertificate();\n      clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));\n      clientcert.validity.notBefore = new Date();\n      clientcert.validity.notAfter = new Date();\n      clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);\n      var clientAttrs = JSON.parse(JSON.stringify(attrs));\n\n      for (var i = 0; i < clientAttrs.length; i++) {\n        if (clientAttrs[i].name === 'commonName') {\n          if (options.clientCertificateCN) clientAttrs[i] = {\n            name: 'commonName',\n            value: options.clientCertificateCN\n          };else clientAttrs[i] = {\n            name: 'commonName',\n            value: 'John Doe jdoe123'\n          };\n        }\n      }\n\n      clientcert.setSubject(clientAttrs); // Set the issuer to the parent key\n\n      clientcert.setIssuer(attrs);\n      clientcert.publicKey = clientkeys.publicKey; // Sign client cert with root cert\n\n      clientcert.sign(keyPair.privateKey);\n      pem.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);\n      pem.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);\n      pem.clientcert = forge.pki.certificateToPem(clientcert);\n\n      if (options.pkcs7) {\n        var clientp7 = forge.pkcs7.createSignedData();\n        clientp7.addCertificate(clientcert);\n        pem.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);\n      }\n    }\n\n    var caStore = forge.pki.createCaStore();\n    caStore.addCertificate(cert);\n\n    try {\n      forge.pki.verifyCertificateChain(caStore, [cert], function (vfd, depth, chain) {\n        if (vfd !== true) {\n          throw new Error('Certificate could not be verified.');\n        }\n\n        return true;\n      });\n    } catch (ex) {\n      throw new Error(ex);\n    }\n\n    return pem;\n  };\n\n  var keySize = options.keySize || 1024;\n\n  if (done) {\n    // async scenario\n    return forge.pki.rsa.generateKeyPair({\n      bits: keySize\n    }, function (err, keyPair) {\n      if (err) {\n        return done(err);\n      }\n\n      try {\n        return done(null, generatePem(keyPair));\n      } catch (ex) {\n        return done(ex);\n      }\n    });\n  }\n\n  var keyPair = options.keyPair ? {\n    privateKey: forge.pki.privateKeyFromPem(options.keyPair.privateKey),\n    publicKey: forge.pki.publicKeyFromPem(options.keyPair.publicKey)\n  } : forge.pki.rsa.generateKeyPair(keySize);\n  return generatePem(keyPair);\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/selfsigned/index.js"],"names":["forge","require","toPositiveHex","hexString","mostSiginficativeHexAsInt","parseInt","toString","substring","getAlgorithm","key","md","sha256","create","sha1","exports","generate","attrs","options","done","undefined","generatePem","keyPair","cert","pki","createCertificate","serialNumber","util","bytesToHex","random","getBytesSync","validity","notBefore","Date","notAfter","setDate","getDate","days","name","value","shortName","setSubject","setIssuer","publicKey","setExtensions","extensions","cA","keyCertSign","digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","altNames","type","sign","privateKey","algorithm","fingerprint","update","asn1","toDer","certificateToAsn1","getBytes","digest","toHex","match","join","pem","private","privateKeyToPem","public","publicKeyToPem","certificateToPem","pkcs7","p7","createSignedData","addCertificate","messageToPem","clientCertificate","clientkeys","rsa","generateKeyPair","clientcert","setFullYear","getFullYear","clientAttrs","JSON","parse","stringify","i","length","clientCertificateCN","clientprivate","clientpublic","clientp7","clientpkcs7","caStore","createCaStore","verifyCertificateChain","vfd","depth","chain","Error","ex","keySize","bits","err","privateKeyFromPem","publicKeyFromPem"],"mappings":"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","sourcesContent":["var forge = require('node-forge');\n\n// a hexString is considered negative if it's most significant bit is 1\n// because serial numbers use ones' complement notation\n// this RFC in section 4.1.2.2 requires serial numbers to be positive\n// http://www.ietf.org/rfc/rfc5280.txt\nfunction toPositiveHex(hexString){\n  var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);\n  if (mostSiginficativeHexAsInt < 8){\n    return hexString;\n  }\n\n  mostSiginficativeHexAsInt -= 8;\n  return mostSiginficativeHexAsInt.toString() + hexString.substring(1);\n}\n\nfunction getAlgorithm(key) {\n  switch (key) {\n    case 'sha256':\n      return forge.md.sha256.create();\n    default:\n      return forge.md.sha1.create();\n  }\n}\n\nexports.generate = function generate(attrs, options, done) {\n  if (typeof attrs === 'function') {\n    done = attrs;\n    attrs = undefined;\n  } else if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var generatePem = function (keyPair) {\n    var cert = forge.pki.createCertificate();\n\n    cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9))); // the serial number can be decimal or hex (if preceded by 0x)\n\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options.days || 365));\n\n    attrs = attrs || [{\n      name: 'commonName',\n      value: 'example.org'\n    }, {\n      name: 'countryName',\n      value: 'US'\n    }, {\n      shortName: 'ST',\n      value: 'Virginia'\n    }, {\n      name: 'localityName',\n      value: 'Blacksburg'\n    }, {\n      name: 'organizationName',\n      value: 'Test'\n    }, {\n      shortName: 'OU',\n      value: 'Test'\n    }];\n\n    cert.setSubject(attrs);\n    cert.setIssuer(attrs);\n\n    cert.publicKey = keyPair.publicKey;\n\n    cert.setExtensions(options.extensions || [{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'subjectAltName',\n      altNames: [{\n        type: 6, // URI\n        value: 'http://example.org/webid#me'\n      }]\n    }]);\n\n    cert.sign(keyPair.privateKey, getAlgorithm(options && options.algorithm));\n\n    const fingerprint = forge.md.sha1\n                          .create()\n                          .update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes())\n                          .digest()\n                          .toHex()\n                          .match(/.{2}/g)\n                          .join(':');\n\n    var pem = {\n      private:     forge.pki.privateKeyToPem(keyPair.privateKey),\n      public:      forge.pki.publicKeyToPem(keyPair.publicKey),\n      cert:        forge.pki.certificateToPem(cert),\n      fingerprint: fingerprint,\n    };\n\n    if (options && options.pkcs7) {\n      var p7 = forge.pkcs7.createSignedData();\n      p7.addCertificate(cert);\n      pem.pkcs7 = forge.pkcs7.messageToPem(p7);\n    }\n\n    if (options && options.clientCertificate) {\n      var clientkeys = forge.pki.rsa.generateKeyPair(1024);\n      var clientcert = forge.pki.createCertificate();\n      clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));\n      clientcert.validity.notBefore = new Date();\n      clientcert.validity.notAfter = new Date();\n      clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);\n\n      var clientAttrs = JSON.parse(JSON.stringify(attrs));\n\n      for(var i = 0; i < clientAttrs.length; i++) {\n        if(clientAttrs[i].name === 'commonName') {\n          if( options.clientCertificateCN )\n            clientAttrs[i] = { name: 'commonName', value: options.clientCertificateCN };\n          else\n            clientAttrs[i] = { name: 'commonName', value: 'John Doe jdoe123' };\n        }\n      }\n\n      clientcert.setSubject(clientAttrs);\n\n      // Set the issuer to the parent key\n      clientcert.setIssuer(attrs);\n\n      clientcert.publicKey = clientkeys.publicKey;\n\n      // Sign client cert with root cert\n      clientcert.sign(keyPair.privateKey);\n\n      pem.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);\n      pem.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);\n      pem.clientcert = forge.pki.certificateToPem(clientcert);\n\n      if (options.pkcs7) {\n        var clientp7 = forge.pkcs7.createSignedData();\n        clientp7.addCertificate(clientcert);\n        pem.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);\n      }\n    }\n\n    var caStore = forge.pki.createCaStore();\n    caStore.addCertificate(cert);\n\n    try {\n      forge.pki.verifyCertificateChain(caStore, [cert],\n        function (vfd, depth, chain) {\n          if (vfd !== true) {\n            throw new Error('Certificate could not be verified.');\n          }\n          return true;\n        });\n    }\n    catch(ex) {\n      throw new Error(ex);\n    }\n\n    return pem;\n  };\n\n  var keySize = options.keySize || 1024;\n\n  if (done) { // async scenario\n    return forge.pki.rsa.generateKeyPair({ bits: keySize }, function (err, keyPair) {\n      if (err) { return done(err); }\n\n      try {\n        return done(null, generatePem(keyPair));\n      } catch (ex) {\n        return done(ex);\n      }\n    });\n  }\n\n  var keyPair = options.keyPair ? {\n    privateKey: forge.pki.privateKeyFromPem(options.keyPair.privateKey),\n    publicKey: forge.pki.publicKeyFromPem(options.keyPair.publicKey)\n  } : forge.pki.rsa.generateKeyPair(keySize);\n\n  return generatePem(keyPair);\n};\n"]},"metadata":{},"sourceType":"script"}