{"ast":null,"code":"var hpack = require('../hpack');\n\nvar utils = hpack.utils;\nvar huffman = hpack.huffman.encode;\nvar assert = utils.assert;\n\nvar WBuf = require('wbuf');\n\nfunction Encoder() {\n  this.buffer = new WBuf();\n  this.word = 0;\n  this.bitOffset = 0;\n}\n\nmodule.exports = Encoder;\n\nEncoder.create = function create() {\n  return new Encoder();\n};\n\nEncoder.prototype.render = function render() {\n  return this.buffer.render();\n};\n\nEncoder.prototype.encodeBit = function encodeBit(bit) {\n  var octet;\n  this.word <<= 1;\n  this.word |= bit;\n  this.bitOffset++;\n\n  if (this.bitOffset === 8) {\n    this.buffer.writeUInt8(this.word);\n    this.word = 0;\n    this.bitOffset = 0;\n  }\n};\n\nEncoder.prototype.encodeBits = function encodeBits(bits, len) {\n  var left = bits;\n  var leftLen = len;\n\n  while (leftLen > 0) {\n    var avail = Math.min(leftLen, 8 - this.bitOffset);\n    var toWrite = left >>> leftLen - avail;\n\n    if (avail === 8) {\n      this.buffer.writeUInt8(toWrite);\n    } else {\n      this.word <<= avail;\n      this.word |= toWrite;\n      this.bitOffset += avail;\n\n      if (this.bitOffset === 8) {\n        this.buffer.writeUInt8(this.word);\n        this.word = 0;\n        this.bitOffset = 0;\n      }\n    }\n\n    leftLen -= avail;\n    left &= (1 << leftLen) - 1;\n  }\n}; // Just for testing\n\n\nEncoder.prototype.skipBits = function skipBits(num) {\n  this.bitOffset += num;\n  this.buffer.skip(this.bitOffset >> 3);\n  this.bitOffset &= 0x7;\n};\n\nEncoder.prototype.encodeInt = function encodeInt(num) {\n  var prefix = 8 - this.bitOffset; // We are going to end up octet-aligned\n\n  this.bitOffset = 0;\n  var max = (1 << prefix) - 1; // Fast case - int fits into the prefix\n\n  if (num < max) {\n    this.buffer.writeUInt8(this.word << prefix | num);\n    return octet;\n  }\n\n  var left = num - max;\n  this.buffer.writeUInt8(this.word << prefix | max);\n\n  do {\n    var octet = left & 0x7f;\n    left >>= 7;\n    if (left !== 0) octet |= 0x80;\n    this.buffer.writeUInt8(octet);\n  } while (left !== 0);\n};\n\nEncoder.prototype.encodeStr = function encodeStr(value, isHuffman) {\n  this.encodeBit(isHuffman ? 1 : 0);\n\n  if (!isHuffman) {\n    this.buffer.reserve(value.length + 1);\n    this.encodeInt(value.length);\n\n    for (var i = 0; i < value.length; i++) this.buffer.writeUInt8(value[i]);\n\n    return;\n  }\n\n  var codes = [];\n  var len = 0;\n  var pad = 0;\n\n  for (var i = 0; i < value.length; i++) {\n    var code = huffman[value[i]];\n    codes.push(code);\n    len += code[0];\n  }\n\n  if (len % 8 !== 0) pad = 8 - len % 8;\n  len += pad;\n  this.buffer.reserve(len / 8 + 1);\n  this.encodeInt(len / 8);\n\n  for (var i = 0; i < codes.length; i++) {\n    var code = codes[i];\n    this.encodeBits(code[1], code[0]);\n  } // Append padding\n\n\n  this.encodeBits(0xff >>> 8 - pad, pad);\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/hpack.js/lib/hpack/encoder.js"],"names":["hpack","require","utils","huffman","encode","assert","WBuf","Encoder","buffer","word","bitOffset","module","exports","create","prototype","render","encodeBit","bit","octet","writeUInt8","encodeBits","bits","len","left","leftLen","avail","Math","min","toWrite","skipBits","num","skip","encodeInt","prefix","max","encodeStr","value","isHuffman","reserve","length","i","codes","pad","code","push"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAIC,KAAK,GAAGF,KAAK,CAACE,KAAlB;AACA,IAAIC,OAAO,GAAGH,KAAK,CAACG,OAAN,CAAcC,MAA5B;AACA,IAAIC,MAAM,GAAGH,KAAK,CAACG,MAAnB;;AAEA,IAAIC,IAAI,GAAGL,OAAO,CAAC,MAAD,CAAlB;;AAEA,SAASM,OAAT,GAAmB;AACjB,OAAKC,MAAL,GAAc,IAAIF,IAAJ,EAAd;AACA,OAAKG,IAAL,GAAY,CAAZ;AACA,OAAKC,SAAL,GAAiB,CAAjB;AACD;;AACDC,MAAM,CAACC,OAAP,GAAiBL,OAAjB;;AAEAA,OAAO,CAACM,MAAR,GAAiB,SAASA,MAAT,GAAkB;AACjC,SAAO,IAAIN,OAAJ,EAAP;AACD,CAFD;;AAIAA,OAAO,CAACO,SAAR,CAAkBC,MAAlB,GAA2B,SAASA,MAAT,GAAkB;AAC3C,SAAO,KAAKP,MAAL,CAAYO,MAAZ,EAAP;AACD,CAFD;;AAIAR,OAAO,CAACO,SAAR,CAAkBE,SAAlB,GAA8B,SAASA,SAAT,CAAmBC,GAAnB,EAAwB;AACpD,MAAIC,KAAJ;AAEA,OAAKT,IAAL,KAAc,CAAd;AACA,OAAKA,IAAL,IAAaQ,GAAb;AACA,OAAKP,SAAL;;AAEA,MAAI,KAAKA,SAAL,KAAmB,CAAvB,EAA0B;AACxB,SAAKF,MAAL,CAAYW,UAAZ,CAAuB,KAAKV,IAA5B;AACA,SAAKA,IAAL,GAAY,CAAZ;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACD;AACF,CAZD;;AAcAH,OAAO,CAACO,SAAR,CAAkBM,UAAlB,GAA+B,SAASA,UAAT,CAAoBC,IAApB,EAA0BC,GAA1B,EAA+B;AAC5D,MAAIC,IAAI,GAAGF,IAAX;AACA,MAAIG,OAAO,GAAGF,GAAd;;AAEA,SAAOE,OAAO,GAAG,CAAjB,EAAoB;AAClB,QAAIC,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASH,OAAT,EAAkB,IAAI,KAAKd,SAA3B,CAAZ;AACA,QAAIkB,OAAO,GAAGL,IAAI,KAAMC,OAAO,GAAGC,KAAlC;;AAEA,QAAIA,KAAK,KAAK,CAAd,EAAiB;AACf,WAAKjB,MAAL,CAAYW,UAAZ,CAAuBS,OAAvB;AACD,KAFD,MAEO;AACL,WAAKnB,IAAL,KAAcgB,KAAd;AACA,WAAKhB,IAAL,IAAamB,OAAb;AACA,WAAKlB,SAAL,IAAkBe,KAAlB;;AACA,UAAI,KAAKf,SAAL,KAAmB,CAAvB,EAA0B;AACxB,aAAKF,MAAL,CAAYW,UAAZ,CAAuB,KAAKV,IAA5B;AACA,aAAKA,IAAL,GAAY,CAAZ;AACA,aAAKC,SAAL,GAAiB,CAAjB;AACD;AACF;;AAEDc,IAAAA,OAAO,IAAIC,KAAX;AACAF,IAAAA,IAAI,IAAI,CAAC,KAAKC,OAAN,IAAiB,CAAzB;AACD;AACF,CAxBD,C,CA0BA;;;AACAjB,OAAO,CAACO,SAAR,CAAkBe,QAAlB,GAA6B,SAASA,QAAT,CAAkBC,GAAlB,EAAuB;AAClD,OAAKpB,SAAL,IAAkBoB,GAAlB;AACA,OAAKtB,MAAL,CAAYuB,IAAZ,CAAiB,KAAKrB,SAAL,IAAkB,CAAnC;AACA,OAAKA,SAAL,IAAkB,GAAlB;AACD,CAJD;;AAMAH,OAAO,CAACO,SAAR,CAAkBkB,SAAlB,GAA8B,SAASA,SAAT,CAAmBF,GAAnB,EAAwB;AACpD,MAAIG,MAAM,GAAG,IAAI,KAAKvB,SAAtB,CADoD,CAGpD;;AACA,OAAKA,SAAL,GAAiB,CAAjB;AAEA,MAAIwB,GAAG,GAAG,CAAC,KAAKD,MAAN,IAAgB,CAA1B,CANoD,CAQpD;;AACA,MAAIH,GAAG,GAAGI,GAAV,EAAe;AACb,SAAK1B,MAAL,CAAYW,UAAZ,CAAwB,KAAKV,IAAL,IAAawB,MAAd,GAAwBH,GAA/C;AACA,WAAOZ,KAAP;AACD;;AAED,MAAIK,IAAI,GAAGO,GAAG,GAAGI,GAAjB;AACA,OAAK1B,MAAL,CAAYW,UAAZ,CAAwB,KAAKV,IAAL,IAAawB,MAAd,GAAwBC,GAA/C;;AACA,KAAG;AACD,QAAIhB,KAAK,GAAGK,IAAI,GAAG,IAAnB;AACAA,IAAAA,IAAI,KAAK,CAAT;AACA,QAAIA,IAAI,KAAK,CAAb,EACEL,KAAK,IAAI,IAAT;AAEF,SAAKV,MAAL,CAAYW,UAAZ,CAAuBD,KAAvB;AACD,GAPD,QAOSK,IAAI,KAAK,CAPlB;AAQD,CAxBD;;AA0BAhB,OAAO,CAACO,SAAR,CAAkBqB,SAAlB,GAA8B,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,SAA1B,EAAqC;AACjE,OAAKrB,SAAL,CAAeqB,SAAS,GAAG,CAAH,GAAO,CAA/B;;AAEA,MAAI,CAACA,SAAL,EAAgB;AACd,SAAK7B,MAAL,CAAY8B,OAAZ,CAAoBF,KAAK,CAACG,MAAN,GAAe,CAAnC;AACA,SAAKP,SAAL,CAAeI,KAAK,CAACG,MAArB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,KAAK,CAACG,MAA1B,EAAkCC,CAAC,EAAnC,EACE,KAAKhC,MAAL,CAAYW,UAAZ,CAAuBiB,KAAK,CAACI,CAAD,CAA5B;;AACF;AACD;;AAED,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAInB,GAAG,GAAG,CAAV;AACA,MAAIoB,GAAG,GAAG,CAAV;;AAEA,OAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,KAAK,CAACG,MAA1B,EAAkCC,CAAC,EAAnC,EAAuC;AACrC,QAAIG,IAAI,GAAGxC,OAAO,CAACiC,KAAK,CAACI,CAAD,CAAN,CAAlB;AACAC,IAAAA,KAAK,CAACG,IAAN,CAAWD,IAAX;AACArB,IAAAA,GAAG,IAAIqB,IAAI,CAAC,CAAD,CAAX;AACD;;AACD,MAAIrB,GAAG,GAAG,CAAN,KAAY,CAAhB,EACEoB,GAAG,GAAG,IAAKpB,GAAG,GAAG,CAAjB;AACFA,EAAAA,GAAG,IAAIoB,GAAP;AAEA,OAAKlC,MAAL,CAAY8B,OAAZ,CAAqBhB,GAAG,GAAG,CAAP,GAAY,CAAhC;AACA,OAAKU,SAAL,CAAeV,GAAG,GAAG,CAArB;;AACA,OAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,KAAK,CAACF,MAA1B,EAAkCC,CAAC,EAAnC,EAAuC;AACrC,QAAIG,IAAI,GAAGF,KAAK,CAACD,CAAD,CAAhB;AACA,SAAKpB,UAAL,CAAgBuB,IAAI,CAAC,CAAD,CAApB,EAAyBA,IAAI,CAAC,CAAD,CAA7B;AACD,GA7BgE,CA+BjE;;;AACA,OAAKvB,UAAL,CAAgB,SAAU,IAAIsB,GAA9B,EAAoCA,GAApC;AACD,CAjCD","sourcesContent":["var hpack = require('../hpack');\nvar utils = hpack.utils;\nvar huffman = hpack.huffman.encode;\nvar assert = utils.assert;\n\nvar WBuf = require('wbuf');\n\nfunction Encoder() {\n  this.buffer = new WBuf();\n  this.word = 0;\n  this.bitOffset = 0;\n}\nmodule.exports = Encoder;\n\nEncoder.create = function create() {\n  return new Encoder();\n};\n\nEncoder.prototype.render = function render() {\n  return this.buffer.render();\n};\n\nEncoder.prototype.encodeBit = function encodeBit(bit) {\n  var octet;\n\n  this.word <<= 1;\n  this.word |= bit;\n  this.bitOffset++;\n\n  if (this.bitOffset === 8) {\n    this.buffer.writeUInt8(this.word);\n    this.word = 0;\n    this.bitOffset = 0;\n  }\n};\n\nEncoder.prototype.encodeBits = function encodeBits(bits, len) {\n  var left = bits;\n  var leftLen = len;\n\n  while (leftLen > 0) {\n    var avail = Math.min(leftLen, 8 - this.bitOffset);\n    var toWrite = left >>> (leftLen - avail);\n\n    if (avail === 8) {\n      this.buffer.writeUInt8(toWrite);\n    } else {\n      this.word <<= avail;\n      this.word |= toWrite;\n      this.bitOffset += avail;\n      if (this.bitOffset === 8) {\n        this.buffer.writeUInt8(this.word);\n        this.word = 0;\n        this.bitOffset = 0;\n      }\n    }\n\n    leftLen -= avail;\n    left &= (1 << leftLen) - 1;\n  }\n};\n\n// Just for testing\nEncoder.prototype.skipBits = function skipBits(num) {\n  this.bitOffset += num;\n  this.buffer.skip(this.bitOffset >> 3);\n  this.bitOffset &= 0x7;\n};\n\nEncoder.prototype.encodeInt = function encodeInt(num) {\n  var prefix = 8 - this.bitOffset;\n\n  // We are going to end up octet-aligned\n  this.bitOffset = 0;\n\n  var max = (1 << prefix) - 1;\n\n  // Fast case - int fits into the prefix\n  if (num < max) {\n    this.buffer.writeUInt8((this.word << prefix) | num);\n    return octet;\n  }\n\n  var left = num - max;\n  this.buffer.writeUInt8((this.word << prefix) | max);\n  do {\n    var octet = left & 0x7f;\n    left >>= 7;\n    if (left !== 0)\n      octet |= 0x80;\n\n    this.buffer.writeUInt8(octet);\n  } while (left !== 0);\n};\n\nEncoder.prototype.encodeStr = function encodeStr(value, isHuffman) {\n  this.encodeBit(isHuffman ? 1 : 0);\n\n  if (!isHuffman) {\n    this.buffer.reserve(value.length + 1);\n    this.encodeInt(value.length);\n    for (var i = 0; i < value.length; i++)\n      this.buffer.writeUInt8(value[i]);\n    return;\n  }\n\n  var codes = [];\n  var len = 0;\n  var pad = 0;\n\n  for (var i = 0; i < value.length; i++) {\n    var code = huffman[value[i]];\n    codes.push(code);\n    len += code[0];\n  }\n  if (len % 8 !== 0)\n    pad = 8 - (len % 8);\n  len += pad;\n\n  this.buffer.reserve((len / 8) + 1);\n  this.encodeInt(len / 8);\n  for (var i = 0; i < codes.length; i++) {\n    var code = codes[i];\n    this.encodeBits(code[1], code[0]);\n  }\n\n  // Append padding\n  this.encodeBits(0xff >>> (8 - pad), pad);\n};\n"]},"metadata":{},"sourceType":"script"}