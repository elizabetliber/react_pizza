{"ast":null,"code":"'use strict';\n\nvar dnsEqual = require('dns-equal');\n\nvar flatten = require('array-flatten');\n\nvar Service = require('./service');\n\nvar REANNOUNCE_MAX_MS = 60 * 60 * 1000;\nvar REANNOUNCE_FACTOR = 3;\nmodule.exports = Registry;\n\nfunction Registry(server) {\n  this._server = server;\n  this._services = [];\n}\n\nRegistry.prototype.publish = function (opts) {\n  var service = new Service(opts);\n  service.start = start.bind(service, this);\n  service.stop = stop.bind(service, this);\n  service.start({\n    probe: opts.probe !== false\n  });\n  return service;\n};\n\nRegistry.prototype.unpublishAll = function (cb) {\n  teardown(this._server, this._services, cb);\n  this._services = [];\n};\n\nRegistry.prototype.destroy = function () {\n  this._services.forEach(function (service) {\n    service._destroyed = true;\n  });\n};\n\nfunction start(registry, opts) {\n  if (this._activated) return;\n  this._activated = true;\n\n  registry._services.push(this);\n\n  if (opts.probe) {\n    var service = this;\n    probe(registry._server.mdns, this, function (exists) {\n      if (exists) {\n        service.stop();\n        service.emit('error', new Error('Service name is already in use on the network'));\n        return;\n      }\n\n      announce(registry._server, service);\n    });\n  } else {\n    announce(registry._server, this);\n  }\n}\n\nfunction stop(registry, cb) {\n  if (!this._activated) return; // TODO: What about the callback?\n\n  teardown(registry._server, this, cb);\n\n  var index = registry._services.indexOf(this);\n\n  if (index !== -1) registry._services.splice(index, 1);\n}\n/**\n * Check if a service name is already in use on the network.\n *\n * Used before announcing the new service.\n *\n * To guard against race conditions where multiple services are started\n * simultaneously on the network, wait a random amount of time (between\n * 0 and 250 ms) before probing.\n *\n * TODO: Add support for Simultaneous Probe Tiebreaking:\n * https://tools.ietf.org/html/rfc6762#section-8.2\n */\n\n\nfunction probe(mdns, service, cb) {\n  var sent = false;\n  var retries = 0;\n  var timer;\n  mdns.on('response', onresponse);\n  setTimeout(send, Math.random() * 250);\n\n  function send() {\n    // abort if the service have or is being stopped in the meantime\n    if (!service._activated || service._destroyed) return;\n    mdns.query(service.fqdn, 'ANY', function () {\n      // This function will optionally be called with an error object. We'll\n      // just silently ignore it and retry as we normally would\n      sent = true;\n      timer = setTimeout(++retries < 3 ? send : done, 250);\n      timer.unref();\n    });\n  }\n\n  function onresponse(packet) {\n    // Apparently conflicting Multicast DNS responses received *before*\n    // the first probe packet is sent MUST be silently ignored (see\n    // discussion of stale probe packets in RFC 6762 Section 8.2,\n    // \"Simultaneous Probe Tiebreaking\" at\n    // https://tools.ietf.org/html/rfc6762#section-8.2\n    if (!sent) return;\n    if (packet.answers.some(matchRR) || packet.additionals.some(matchRR)) done(true);\n  }\n\n  function matchRR(rr) {\n    return dnsEqual(rr.name, service.fqdn);\n  }\n\n  function done(exists) {\n    mdns.removeListener('response', onresponse);\n    clearTimeout(timer);\n    cb(!!exists);\n  }\n}\n/**\n * Initial service announcement\n *\n * Used to announce new services when they are first registered.\n *\n * Broadcasts right away, then after 3 seconds, 9 seconds, 27 seconds,\n * and so on, up to a maximum interval of one hour.\n */\n\n\nfunction announce(server, service) {\n  var delay = 1000;\n\n  var packet = service._records();\n\n  server.register(packet);\n\n  (function broadcast() {\n    // abort if the service have or is being stopped in the meantime\n    if (!service._activated || service._destroyed) return;\n    server.mdns.respond(packet, function () {\n      // This function will optionally be called with an error object. We'll\n      // just silently ignore it and retry as we normally would\n      if (!service.published) {\n        service._activated = true;\n        service.published = true;\n        service.emit('up');\n      }\n\n      delay = delay * REANNOUNCE_FACTOR;\n\n      if (delay < REANNOUNCE_MAX_MS && !service._destroyed) {\n        setTimeout(broadcast, delay).unref();\n      }\n    });\n  })();\n}\n/**\n * Stop the given services\n *\n * Besides removing a service from the mDNS registry, a \"goodbye\"\n * message is sent for each service to let the network know about the\n * shutdown.\n */\n\n\nfunction teardown(server, services, cb) {\n  if (!Array.isArray(services)) services = [services];\n  services = services.filter(function (service) {\n    return service._activated; // ignore services not currently starting or started\n  });\n  var records = flatten.depth(services.map(function (service) {\n    service._activated = false;\n\n    var records = service._records();\n\n    records.forEach(function (record) {\n      record.ttl = 0; // prepare goodbye message\n    });\n    return records;\n  }), 1);\n  if (records.length === 0) return cb && cb();\n  server.unregister(records); // send goodbye message\n\n  server.mdns.respond(records, function () {\n    services.forEach(function (service) {\n      service.published = false;\n    });\n    if (cb) cb.apply(null, arguments);\n  });\n}","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/bonjour/lib/registry.js"],"names":["dnsEqual","require","flatten","Service","REANNOUNCE_MAX_MS","REANNOUNCE_FACTOR","module","exports","Registry","server","_server","_services","prototype","publish","opts","service","start","bind","stop","probe","unpublishAll","cb","teardown","destroy","forEach","_destroyed","registry","_activated","push","mdns","exists","emit","Error","announce","index","indexOf","splice","sent","retries","timer","on","onresponse","setTimeout","send","Math","random","query","fqdn","done","unref","packet","answers","some","matchRR","additionals","rr","name","removeListener","clearTimeout","delay","_records","register","broadcast","respond","published","services","Array","isArray","filter","records","depth","map","record","ttl","length","unregister","apply","arguments"],"mappings":"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","sourcesContent":["'use strict'\n\nvar dnsEqual = require('dns-equal')\nvar flatten = require('array-flatten')\nvar Service = require('./service')\n\nvar REANNOUNCE_MAX_MS = 60 * 60 * 1000\nvar REANNOUNCE_FACTOR = 3\n\nmodule.exports = Registry\n\nfunction Registry (server) {\n  this._server = server\n  this._services = []\n}\n\nRegistry.prototype.publish = function (opts) {\n  var service = new Service(opts)\n  service.start = start.bind(service, this)\n  service.stop = stop.bind(service, this)\n  service.start({ probe: opts.probe !== false })\n  return service\n}\n\nRegistry.prototype.unpublishAll = function (cb) {\n  teardown(this._server, this._services, cb)\n  this._services = []\n}\n\nRegistry.prototype.destroy = function () {\n  this._services.forEach(function (service) {\n    service._destroyed = true\n  })\n}\n\nfunction start (registry, opts) {\n  if (this._activated) return\n  this._activated = true\n\n  registry._services.push(this)\n\n  if (opts.probe) {\n    var service = this\n    probe(registry._server.mdns, this, function (exists) {\n      if (exists) {\n        service.stop()\n        service.emit('error', new Error('Service name is already in use on the network'))\n        return\n      }\n      announce(registry._server, service)\n    })\n  } else {\n    announce(registry._server, this)\n  }\n}\n\nfunction stop (registry, cb) {\n  if (!this._activated) return // TODO: What about the callback?\n\n  teardown(registry._server, this, cb)\n\n  var index = registry._services.indexOf(this)\n  if (index !== -1) registry._services.splice(index, 1)\n}\n\n/**\n * Check if a service name is already in use on the network.\n *\n * Used before announcing the new service.\n *\n * To guard against race conditions where multiple services are started\n * simultaneously on the network, wait a random amount of time (between\n * 0 and 250 ms) before probing.\n *\n * TODO: Add support for Simultaneous Probe Tiebreaking:\n * https://tools.ietf.org/html/rfc6762#section-8.2\n */\nfunction probe (mdns, service, cb) {\n  var sent = false\n  var retries = 0\n  var timer\n\n  mdns.on('response', onresponse)\n  setTimeout(send, Math.random() * 250)\n\n  function send () {\n    // abort if the service have or is being stopped in the meantime\n    if (!service._activated || service._destroyed) return\n\n    mdns.query(service.fqdn, 'ANY', function () {\n      // This function will optionally be called with an error object. We'll\n      // just silently ignore it and retry as we normally would\n      sent = true\n      timer = setTimeout(++retries < 3 ? send : done, 250)\n      timer.unref()\n    })\n  }\n\n  function onresponse (packet) {\n    // Apparently conflicting Multicast DNS responses received *before*\n    // the first probe packet is sent MUST be silently ignored (see\n    // discussion of stale probe packets in RFC 6762 Section 8.2,\n    // \"Simultaneous Probe Tiebreaking\" at\n    // https://tools.ietf.org/html/rfc6762#section-8.2\n    if (!sent) return\n\n    if (packet.answers.some(matchRR) || packet.additionals.some(matchRR)) done(true)\n  }\n\n  function matchRR (rr) {\n    return dnsEqual(rr.name, service.fqdn)\n  }\n\n  function done (exists) {\n    mdns.removeListener('response', onresponse)\n    clearTimeout(timer)\n    cb(!!exists)\n  }\n}\n\n/**\n * Initial service announcement\n *\n * Used to announce new services when they are first registered.\n *\n * Broadcasts right away, then after 3 seconds, 9 seconds, 27 seconds,\n * and so on, up to a maximum interval of one hour.\n */\nfunction announce (server, service) {\n  var delay = 1000\n  var packet = service._records()\n\n  server.register(packet)\n\n  ;(function broadcast () {\n    // abort if the service have or is being stopped in the meantime\n    if (!service._activated || service._destroyed) return\n\n    server.mdns.respond(packet, function () {\n      // This function will optionally be called with an error object. We'll\n      // just silently ignore it and retry as we normally would\n      if (!service.published) {\n        service._activated = true\n        service.published = true\n        service.emit('up')\n      }\n      delay = delay * REANNOUNCE_FACTOR\n      if (delay < REANNOUNCE_MAX_MS && !service._destroyed) {\n        setTimeout(broadcast, delay).unref()\n      }\n    })\n  })()\n}\n\n/**\n * Stop the given services\n *\n * Besides removing a service from the mDNS registry, a \"goodbye\"\n * message is sent for each service to let the network know about the\n * shutdown.\n */\nfunction teardown (server, services, cb) {\n  if (!Array.isArray(services)) services = [services]\n\n  services = services.filter(function (service) {\n    return service._activated // ignore services not currently starting or started\n  })\n\n  var records = flatten.depth(services.map(function (service) {\n    service._activated = false\n    var records = service._records()\n    records.forEach(function (record) {\n      record.ttl = 0 // prepare goodbye message\n    })\n    return records\n  }), 1)\n\n  if (records.length === 0) return cb && cb()\n\n  server.unregister(records)\n\n  // send goodbye message\n  server.mdns.respond(records, function () {\n    services.forEach(function (service) {\n      service.published = false\n    })\n    if (cb) cb.apply(null, arguments)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}