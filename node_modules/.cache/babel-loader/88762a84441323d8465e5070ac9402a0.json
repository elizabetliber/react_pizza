{"ast":null,"code":"'use strict';\n\nvar multicastdns = require('multicast-dns');\n\nvar dnsEqual = require('dns-equal');\n\nvar flatten = require('array-flatten');\n\nvar deepEqual = require('deep-equal');\n\nmodule.exports = Server;\n\nfunction Server(opts) {\n  this.mdns = multicastdns(opts);\n  this.mdns.setMaxListeners(0);\n  this.registry = {};\n  this.mdns.on('query', this._respondToQuery.bind(this));\n}\n\nServer.prototype.register = function (records) {\n  var self = this;\n  if (Array.isArray(records)) records.forEach(register);else register(records);\n\n  function register(record) {\n    var subRegistry = self.registry[record.type];\n    if (!subRegistry) subRegistry = self.registry[record.type] = [];else if (subRegistry.some(isDuplicateRecord(record))) return;\n    subRegistry.push(record);\n  }\n};\n\nServer.prototype.unregister = function (records) {\n  var self = this;\n  if (Array.isArray(records)) records.forEach(unregister);else unregister(records);\n\n  function unregister(record) {\n    var type = record.type;\n    if (!(type in self.registry)) return;\n    self.registry[type] = self.registry[type].filter(function (r) {\n      return r.name !== record.name;\n    });\n  }\n};\n\nServer.prototype._respondToQuery = function (query) {\n  var self = this;\n  query.questions.forEach(function (question) {\n    var type = question.type;\n    var name = question.name; // generate the answers section\n\n    var answers = type === 'ANY' ? flatten.depth(Object.keys(self.registry).map(self._recordsFor.bind(self, name)), 1) : self._recordsFor(name, type);\n    if (answers.length === 0) return; // generate the additionals section\n\n    var additionals = [];\n\n    if (type !== 'ANY') {\n      answers.forEach(function (answer) {\n        if (answer.type !== 'PTR') return;\n        additionals = additionals.concat(self._recordsFor(answer.data, 'SRV')).concat(self._recordsFor(answer.data, 'TXT'));\n      }); // to populate the A and AAAA records, we need to get a set of unique\n      // targets from the SRV record\n\n      additionals.filter(function (record) {\n        return record.type === 'SRV';\n      }).map(function (record) {\n        return record.data.target;\n      }).filter(unique()).forEach(function (target) {\n        additionals = additionals.concat(self._recordsFor(target, 'A')).concat(self._recordsFor(target, 'AAAA'));\n      });\n    }\n\n    self.mdns.respond({\n      answers: answers,\n      additionals: additionals\n    }, function (err) {\n      if (err) throw err; // TODO: Handle this (if no callback is given, the error will be ignored)\n    });\n  });\n};\n\nServer.prototype._recordsFor = function (name, type) {\n  if (!(type in this.registry)) return [];\n  return this.registry[type].filter(function (record) {\n    var _name = ~name.indexOf('.') ? record.name : record.name.split('.')[0];\n\n    return dnsEqual(_name, name);\n  });\n};\n\nfunction isDuplicateRecord(a) {\n  return function (b) {\n    return a.type === b.type && a.name === b.name && deepEqual(a.data, b.data);\n  };\n}\n\nfunction unique() {\n  var set = [];\n  return function (obj) {\n    if (~set.indexOf(obj)) return false;\n    set.push(obj);\n    return true;\n  };\n}","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/bonjour/lib/mdns-server.js"],"names":["multicastdns","require","dnsEqual","flatten","deepEqual","module","exports","Server","opts","mdns","setMaxListeners","registry","on","_respondToQuery","bind","prototype","register","records","self","Array","isArray","forEach","record","subRegistry","type","some","isDuplicateRecord","push","unregister","filter","r","name","query","questions","question","answers","depth","Object","keys","map","_recordsFor","length","additionals","answer","concat","data","target","unique","respond","err","_name","indexOf","split","a","b","set","obj"],"mappings":"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","sourcesContent":["'use strict'\n\nvar multicastdns = require('multicast-dns')\nvar dnsEqual = require('dns-equal')\nvar flatten = require('array-flatten')\nvar deepEqual = require('deep-equal')\n\nmodule.exports = Server\n\nfunction Server (opts) {\n  this.mdns = multicastdns(opts)\n  this.mdns.setMaxListeners(0)\n  this.registry = {}\n  this.mdns.on('query', this._respondToQuery.bind(this))\n}\n\nServer.prototype.register = function (records) {\n  var self = this\n\n  if (Array.isArray(records)) records.forEach(register)\n  else register(records)\n\n  function register (record) {\n    var subRegistry = self.registry[record.type]\n    if (!subRegistry) subRegistry = self.registry[record.type] = []\n    else if (subRegistry.some(isDuplicateRecord(record))) return\n    subRegistry.push(record)\n  }\n}\n\nServer.prototype.unregister = function (records) {\n  var self = this\n\n  if (Array.isArray(records)) records.forEach(unregister)\n  else unregister(records)\n\n  function unregister (record) {\n    var type = record.type\n    if (!(type in self.registry)) return\n    self.registry[type] = self.registry[type].filter(function (r) {\n      return r.name !== record.name\n    })\n  }\n}\n\nServer.prototype._respondToQuery = function (query) {\n  var self = this\n  query.questions.forEach(function (question) {\n    var type = question.type\n    var name = question.name\n\n    // generate the answers section\n    var answers = type === 'ANY'\n      ? flatten.depth(Object.keys(self.registry).map(self._recordsFor.bind(self, name)), 1)\n      : self._recordsFor(name, type)\n\n    if (answers.length === 0) return\n\n    // generate the additionals section\n    var additionals = []\n    if (type !== 'ANY') {\n      answers.forEach(function (answer) {\n        if (answer.type !== 'PTR') return\n        additionals = additionals\n          .concat(self._recordsFor(answer.data, 'SRV'))\n          .concat(self._recordsFor(answer.data, 'TXT'))\n      })\n\n      // to populate the A and AAAA records, we need to get a set of unique\n      // targets from the SRV record\n      additionals\n        .filter(function (record) {\n          return record.type === 'SRV'\n        })\n        .map(function (record) {\n          return record.data.target\n        })\n        .filter(unique())\n        .forEach(function (target) {\n          additionals = additionals\n            .concat(self._recordsFor(target, 'A'))\n            .concat(self._recordsFor(target, 'AAAA'))\n        })\n    }\n\n    self.mdns.respond({ answers: answers, additionals: additionals }, function (err) {\n      if (err) throw err // TODO: Handle this (if no callback is given, the error will be ignored)\n    })\n  })\n}\n\nServer.prototype._recordsFor = function (name, type) {\n  if (!(type in this.registry)) return []\n\n  return this.registry[type].filter(function (record) {\n    var _name = ~name.indexOf('.') ? record.name : record.name.split('.')[0]\n    return dnsEqual(_name, name)\n  })\n}\n\nfunction isDuplicateRecord (a) {\n  return function (b) {\n    return a.type === b.type &&\n      a.name === b.name &&\n      deepEqual(a.data, b.data)\n  }\n}\n\nfunction unique () {\n  var set = []\n  return function (obj) {\n    if (~set.indexOf(obj)) return false\n    set.push(obj)\n    return true\n  }\n}\n"]},"metadata":{},"sourceType":"script"}