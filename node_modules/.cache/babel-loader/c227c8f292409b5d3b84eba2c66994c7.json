{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar serviceName = require('multicast-dns-service-types');\n\nvar dnsEqual = require('dns-equal');\n\nvar dnsTxt = require('dns-txt');\n\nvar TLD = '.local';\nvar WILDCARD = '_services._dns-sd._udp' + TLD;\nmodule.exports = Browser;\nutil.inherits(Browser, EventEmitter);\n/**\n * Start a browser\n *\n * The browser listens for services by querying for PTR records of a given\n * type, protocol and domain, e.g. _http._tcp.local.\n *\n * If no type is given, a wild card search is performed.\n *\n * An internal list of online services is kept which starts out empty. When\n * ever a new service is discovered, it's added to the list and an \"up\" event\n * is emitted with that service. When it's discovered that the service is no\n * longer available, it is removed from the list and a \"down\" event is emitted\n * with that service.\n */\n\nfunction Browser(mdns, opts, onup) {\n  if (typeof opts === 'function') return new Browser(mdns, null, opts);\n  EventEmitter.call(this);\n  this._mdns = mdns;\n  this._onresponse = null;\n  this._serviceMap = {};\n  this._txt = dnsTxt(opts.txt);\n\n  if (!opts || !opts.type) {\n    this._name = WILDCARD;\n    this._wildcard = true;\n  } else {\n    this._name = serviceName.stringify(opts.type, opts.protocol || 'tcp') + TLD;\n    if (opts.name) this._name = opts.name + '.' + this._name;\n    this._wildcard = false;\n  }\n\n  this.services = [];\n  if (onup) this.on('up', onup);\n  this.start();\n}\n\nBrowser.prototype.start = function () {\n  if (this._onresponse) return;\n  var self = this; // List of names for the browser to listen for. In a normal search this will\n  // be the primary name stored on the browser. In case of a wildcard search\n  // the names will be determined at runtime as responses come in.\n\n  var nameMap = {};\n  if (!this._wildcard) nameMap[this._name] = true;\n\n  this._onresponse = function (packet, rinfo) {\n    if (self._wildcard) {\n      packet.answers.forEach(function (answer) {\n        if (answer.type !== 'PTR' || answer.name !== self._name || answer.name in nameMap) return;\n        nameMap[answer.data] = true;\n\n        self._mdns.query(answer.data, 'PTR');\n      });\n    }\n\n    Object.keys(nameMap).forEach(function (name) {\n      // unregister all services shutting down\n      goodbyes(name, packet).forEach(self._removeService.bind(self)); // register all new services\n\n      var matches = buildServicesFor(name, packet, self._txt, rinfo);\n      if (matches.length === 0) return;\n      matches.forEach(function (service) {\n        if (self._serviceMap[service.fqdn]) return; // ignore already registered services\n\n        self._addService(service);\n      });\n    });\n  };\n\n  this._mdns.on('response', this._onresponse);\n\n  this.update();\n};\n\nBrowser.prototype.stop = function () {\n  if (!this._onresponse) return;\n\n  this._mdns.removeListener('response', this._onresponse);\n\n  this._onresponse = null;\n};\n\nBrowser.prototype.update = function () {\n  this._mdns.query(this._name, 'PTR');\n};\n\nBrowser.prototype._addService = function (service) {\n  this.services.push(service);\n  this._serviceMap[service.fqdn] = true;\n  this.emit('up', service);\n};\n\nBrowser.prototype._removeService = function (fqdn) {\n  var service, index;\n  this.services.some(function (s, i) {\n    if (dnsEqual(s.fqdn, fqdn)) {\n      service = s;\n      index = i;\n      return true;\n    }\n  });\n  if (!service) return;\n  this.services.splice(index, 1);\n  delete this._serviceMap[fqdn];\n  this.emit('down', service);\n}; // PTR records with a TTL of 0 is considered a \"goodbye\" announcement. I.e. a\n// DNS response broadcasted when a service shuts down in order to let the\n// network know that the service is no longer going to be available.\n//\n// For more info see:\n// https://tools.ietf.org/html/rfc6762#section-8.4\n//\n// This function returns an array of all resource records considered a goodbye\n// record\n\n\nfunction goodbyes(name, packet) {\n  return packet.answers.concat(packet.additionals).filter(function (rr) {\n    return rr.type === 'PTR' && rr.ttl === 0 && dnsEqual(rr.name, name);\n  }).map(function (rr) {\n    return rr.data;\n  });\n}\n\nfunction buildServicesFor(name, packet, txt, referer) {\n  var records = packet.answers.concat(packet.additionals).filter(function (rr) {\n    return rr.ttl > 0; // ignore goodbye messages\n  });\n  return records.filter(function (rr) {\n    return rr.type === 'PTR' && dnsEqual(rr.name, name);\n  }).map(function (ptr) {\n    var service = {\n      addresses: []\n    };\n    records.filter(function (rr) {\n      return (rr.type === 'SRV' || rr.type === 'TXT') && dnsEqual(rr.name, ptr.data);\n    }).forEach(function (rr) {\n      if (rr.type === 'SRV') {\n        var parts = rr.name.split('.');\n        var name = parts[0];\n        var types = serviceName.parse(parts.slice(1, -1).join('.'));\n        service.name = name;\n        service.fqdn = rr.name;\n        service.host = rr.data.target;\n        service.referer = referer;\n        service.port = rr.data.port;\n        service.type = types.name;\n        service.protocol = types.protocol;\n        service.subtypes = types.subtypes;\n      } else if (rr.type === 'TXT') {\n        service.rawTxt = rr.data;\n        service.txt = txt.decode(rr.data);\n      }\n    });\n    if (!service.name) return;\n    records.filter(function (rr) {\n      return (rr.type === 'A' || rr.type === 'AAAA') && dnsEqual(rr.name, service.host);\n    }).forEach(function (rr) {\n      service.addresses.push(rr.data);\n    });\n    return service;\n  }).filter(function (rr) {\n    return !!rr;\n  });\n}","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/bonjour/lib/browser.js"],"names":["util","require","EventEmitter","serviceName","dnsEqual","dnsTxt","TLD","WILDCARD","module","exports","Browser","inherits","mdns","opts","onup","call","_mdns","_onresponse","_serviceMap","_txt","txt","type","_name","_wildcard","stringify","protocol","name","services","on","start","prototype","self","nameMap","packet","rinfo","answers","forEach","answer","data","query","Object","keys","goodbyes","_removeService","bind","matches","buildServicesFor","length","service","fqdn","_addService","update","stop","removeListener","push","emit","index","some","s","i","splice","concat","additionals","filter","rr","ttl","map","referer","records","ptr","addresses","parts","split","types","parse","slice","join","host","target","port","subtypes","rawTxt","decode"],"mappings":"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","sourcesContent":["'use strict'\n\nvar util = require('util')\nvar EventEmitter = require('events').EventEmitter\nvar serviceName = require('multicast-dns-service-types')\nvar dnsEqual = require('dns-equal')\nvar dnsTxt = require('dns-txt')\n\nvar TLD = '.local'\nvar WILDCARD = '_services._dns-sd._udp' + TLD\n\nmodule.exports = Browser\n\nutil.inherits(Browser, EventEmitter)\n\n/**\n * Start a browser\n *\n * The browser listens for services by querying for PTR records of a given\n * type, protocol and domain, e.g. _http._tcp.local.\n *\n * If no type is given, a wild card search is performed.\n *\n * An internal list of online services is kept which starts out empty. When\n * ever a new service is discovered, it's added to the list and an \"up\" event\n * is emitted with that service. When it's discovered that the service is no\n * longer available, it is removed from the list and a \"down\" event is emitted\n * with that service.\n */\nfunction Browser (mdns, opts, onup) {\n  if (typeof opts === 'function') return new Browser(mdns, null, opts)\n\n  EventEmitter.call(this)\n\n  this._mdns = mdns\n  this._onresponse = null\n  this._serviceMap = {}\n  this._txt = dnsTxt(opts.txt)\n\n  if (!opts || !opts.type) {\n    this._name = WILDCARD\n    this._wildcard = true\n  } else {\n    this._name = serviceName.stringify(opts.type, opts.protocol || 'tcp') + TLD\n    if (opts.name) this._name = opts.name + '.' + this._name\n    this._wildcard = false\n  }\n\n  this.services = []\n\n  if (onup) this.on('up', onup)\n\n  this.start()\n}\n\nBrowser.prototype.start = function () {\n  if (this._onresponse) return\n\n  var self = this\n\n  // List of names for the browser to listen for. In a normal search this will\n  // be the primary name stored on the browser. In case of a wildcard search\n  // the names will be determined at runtime as responses come in.\n  var nameMap = {}\n  if (!this._wildcard) nameMap[this._name] = true\n\n  this._onresponse = function (packet, rinfo) {\n    if (self._wildcard) {\n      packet.answers.forEach(function (answer) {\n        if (answer.type !== 'PTR' || answer.name !== self._name || answer.name in nameMap) return\n        nameMap[answer.data] = true\n        self._mdns.query(answer.data, 'PTR')\n      })\n    }\n\n    Object.keys(nameMap).forEach(function (name) {\n      // unregister all services shutting down\n      goodbyes(name, packet).forEach(self._removeService.bind(self))\n\n      // register all new services\n      var matches = buildServicesFor(name, packet, self._txt, rinfo)\n      if (matches.length === 0) return\n\n      matches.forEach(function (service) {\n        if (self._serviceMap[service.fqdn]) return // ignore already registered services\n        self._addService(service)\n      })\n    })\n  }\n\n  this._mdns.on('response', this._onresponse)\n  this.update()\n}\n\nBrowser.prototype.stop = function () {\n  if (!this._onresponse) return\n\n  this._mdns.removeListener('response', this._onresponse)\n  this._onresponse = null\n}\n\nBrowser.prototype.update = function () {\n  this._mdns.query(this._name, 'PTR')\n}\n\nBrowser.prototype._addService = function (service) {\n  this.services.push(service)\n  this._serviceMap[service.fqdn] = true\n  this.emit('up', service)\n}\n\nBrowser.prototype._removeService = function (fqdn) {\n  var service, index\n  this.services.some(function (s, i) {\n    if (dnsEqual(s.fqdn, fqdn)) {\n      service = s\n      index = i\n      return true\n    }\n  })\n  if (!service) return\n  this.services.splice(index, 1)\n  delete this._serviceMap[fqdn]\n  this.emit('down', service)\n}\n\n// PTR records with a TTL of 0 is considered a \"goodbye\" announcement. I.e. a\n// DNS response broadcasted when a service shuts down in order to let the\n// network know that the service is no longer going to be available.\n//\n// For more info see:\n// https://tools.ietf.org/html/rfc6762#section-8.4\n//\n// This function returns an array of all resource records considered a goodbye\n// record\nfunction goodbyes (name, packet) {\n  return packet.answers.concat(packet.additionals)\n    .filter(function (rr) {\n      return rr.type === 'PTR' && rr.ttl === 0 && dnsEqual(rr.name, name)\n    })\n    .map(function (rr) {\n      return rr.data\n    })\n}\n\nfunction buildServicesFor (name, packet, txt, referer) {\n  var records = packet.answers.concat(packet.additionals).filter(function (rr) {\n    return rr.ttl > 0 // ignore goodbye messages\n  })\n\n  return records\n    .filter(function (rr) {\n      return rr.type === 'PTR' && dnsEqual(rr.name, name)\n    })\n    .map(function (ptr) {\n      var service = {\n        addresses: []\n      }\n\n      records\n        .filter(function (rr) {\n          return (rr.type === 'SRV' || rr.type === 'TXT') && dnsEqual(rr.name, ptr.data)\n        })\n        .forEach(function (rr) {\n          if (rr.type === 'SRV') {\n            var parts = rr.name.split('.')\n            var name = parts[0]\n            var types = serviceName.parse(parts.slice(1, -1).join('.'))\n            service.name = name\n            service.fqdn = rr.name\n            service.host = rr.data.target\n            service.referer = referer\n            service.port = rr.data.port\n            service.type = types.name\n            service.protocol = types.protocol\n            service.subtypes = types.subtypes\n          } else if (rr.type === 'TXT') {\n            service.rawTxt = rr.data\n            service.txt = txt.decode(rr.data)\n          }\n        })\n\n      if (!service.name) return\n\n      records\n        .filter(function (rr) {\n          return (rr.type === 'A' || rr.type === 'AAAA') && dnsEqual(rr.name, service.host)\n        })\n        .forEach(function (rr) {\n          service.addresses.push(rr.data)\n        })\n\n      return service\n    })\n    .filter(function (rr) {\n      return !!rr\n    })\n}\n"]},"metadata":{},"sourceType":"script"}