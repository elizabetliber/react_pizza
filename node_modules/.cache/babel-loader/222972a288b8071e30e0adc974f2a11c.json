{"ast":null,"code":"'use strict';\n/* eslint-disable\n  no-shadow,\n  no-undefined\n*/\n\nconst webpack = require('webpack');\n\nconst addEntries = require('./addEntries');\n\nconst getSocketClientPath = require('./getSocketClientPath');\n\nfunction updateCompiler(compiler, options) {\n  if (options.inline !== false) {\n    const findHMRPlugin = config => {\n      if (!config.plugins) {\n        return undefined;\n      }\n\n      return config.plugins.find(plugin => plugin.constructor === webpack.HotModuleReplacementPlugin);\n    };\n\n    const compilers = [];\n    const compilersWithoutHMR = [];\n    let webpackConfig;\n\n    if (compiler.compilers) {\n      webpackConfig = [];\n      compiler.compilers.forEach(compiler => {\n        webpackConfig.push(compiler.options);\n        compilers.push(compiler);\n\n        if (!findHMRPlugin(compiler.options)) {\n          compilersWithoutHMR.push(compiler);\n        }\n      });\n    } else {\n      webpackConfig = compiler.options;\n      compilers.push(compiler);\n\n      if (!findHMRPlugin(compiler.options)) {\n        compilersWithoutHMR.push(compiler);\n      }\n    } // it's possible that we should clone the config before doing\n    // this, but it seems safe not to since it actually reflects\n    // the changes we are making to the compiler\n    // important: this relies on the fact that addEntries now\n    // prevents duplicate new entries.\n\n\n    addEntries(webpackConfig, options);\n    compilers.forEach(compiler => {\n      const config = compiler.options;\n      compiler.hooks.entryOption.call(config.context, config.entry);\n      const providePlugin = new webpack.ProvidePlugin({\n        __webpack_dev_server_client__: getSocketClientPath(options)\n      });\n      providePlugin.apply(compiler);\n    }); // do not apply the plugin unless it didn't exist before.\n\n    if (options.hot || options.hotOnly) {\n      compilersWithoutHMR.forEach(compiler => {\n        // addDevServerEntrypoints above should have added the plugin\n        // to the compiler options\n        const plugin = findHMRPlugin(compiler.options);\n\n        if (plugin) {\n          plugin.apply(compiler);\n        }\n      });\n    }\n  }\n}\n\nmodule.exports = updateCompiler;","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/webpack-dev-server/lib/utils/updateCompiler.js"],"names":["webpack","require","addEntries","getSocketClientPath","updateCompiler","compiler","options","inline","findHMRPlugin","config","plugins","undefined","find","plugin","constructor","HotModuleReplacementPlugin","compilers","compilersWithoutHMR","webpackConfig","forEach","push","hooks","entryOption","call","context","entry","providePlugin","ProvidePlugin","__webpack_dev_server_client__","apply","hot","hotOnly","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAME,mBAAmB,GAAGF,OAAO,CAAC,uBAAD,CAAnC;;AAEA,SAASG,cAAT,CAAwBC,QAAxB,EAAkCC,OAAlC,EAA2C;AACzC,MAAIA,OAAO,CAACC,MAAR,KAAmB,KAAvB,EAA8B;AAC5B,UAAMC,aAAa,GAAIC,MAAD,IAAY;AAChC,UAAI,CAACA,MAAM,CAACC,OAAZ,EAAqB;AACnB,eAAOC,SAAP;AACD;;AAED,aAAOF,MAAM,CAACC,OAAP,CAAeE,IAAf,CACJC,MAAD,IAAYA,MAAM,CAACC,WAAP,KAAuBd,OAAO,CAACe,0BADtC,CAAP;AAGD,KARD;;AAUA,UAAMC,SAAS,GAAG,EAAlB;AACA,UAAMC,mBAAmB,GAAG,EAA5B;AACA,QAAIC,aAAJ;;AACA,QAAIb,QAAQ,CAACW,SAAb,EAAwB;AACtBE,MAAAA,aAAa,GAAG,EAAhB;AACAb,MAAAA,QAAQ,CAACW,SAAT,CAAmBG,OAAnB,CAA4Bd,QAAD,IAAc;AACvCa,QAAAA,aAAa,CAACE,IAAd,CAAmBf,QAAQ,CAACC,OAA5B;AACAU,QAAAA,SAAS,CAACI,IAAV,CAAef,QAAf;;AACA,YAAI,CAACG,aAAa,CAACH,QAAQ,CAACC,OAAV,CAAlB,EAAsC;AACpCW,UAAAA,mBAAmB,CAACG,IAApB,CAAyBf,QAAzB;AACD;AACF,OAND;AAOD,KATD,MASO;AACLa,MAAAA,aAAa,GAAGb,QAAQ,CAACC,OAAzB;AACAU,MAAAA,SAAS,CAACI,IAAV,CAAef,QAAf;;AACA,UAAI,CAACG,aAAa,CAACH,QAAQ,CAACC,OAAV,CAAlB,EAAsC;AACpCW,QAAAA,mBAAmB,CAACG,IAApB,CAAyBf,QAAzB;AACD;AACF,KA7B2B,CA+B5B;AACA;AACA;AACA;AACA;;;AACAH,IAAAA,UAAU,CAACgB,aAAD,EAAgBZ,OAAhB,CAAV;AACAU,IAAAA,SAAS,CAACG,OAAV,CAAmBd,QAAD,IAAc;AAC9B,YAAMI,MAAM,GAAGJ,QAAQ,CAACC,OAAxB;AACAD,MAAAA,QAAQ,CAACgB,KAAT,CAAeC,WAAf,CAA2BC,IAA3B,CAAgCd,MAAM,CAACe,OAAvC,EAAgDf,MAAM,CAACgB,KAAvD;AAEA,YAAMC,aAAa,GAAG,IAAI1B,OAAO,CAAC2B,aAAZ,CAA0B;AAC9CC,QAAAA,6BAA6B,EAAEzB,mBAAmB,CAACG,OAAD;AADJ,OAA1B,CAAtB;AAGAoB,MAAAA,aAAa,CAACG,KAAd,CAAoBxB,QAApB;AACD,KARD,EArC4B,CA+C5B;;AACA,QAAIC,OAAO,CAACwB,GAAR,IAAexB,OAAO,CAACyB,OAA3B,EAAoC;AAClCd,MAAAA,mBAAmB,CAACE,OAApB,CAA6Bd,QAAD,IAAc;AACxC;AACA;AACA,cAAMQ,MAAM,GAAGL,aAAa,CAACH,QAAQ,CAACC,OAAV,CAA5B;;AACA,YAAIO,MAAJ,EAAY;AACVA,UAAAA,MAAM,CAACgB,KAAP,CAAaxB,QAAb;AACD;AACF,OAPD;AAQD;AACF;AACF;;AAED2B,MAAM,CAACC,OAAP,GAAiB7B,cAAjB","sourcesContent":["'use strict';\n\n/* eslint-disable\n  no-shadow,\n  no-undefined\n*/\nconst webpack = require('webpack');\nconst addEntries = require('./addEntries');\nconst getSocketClientPath = require('./getSocketClientPath');\n\nfunction updateCompiler(compiler, options) {\n  if (options.inline !== false) {\n    const findHMRPlugin = (config) => {\n      if (!config.plugins) {\n        return undefined;\n      }\n\n      return config.plugins.find(\n        (plugin) => plugin.constructor === webpack.HotModuleReplacementPlugin\n      );\n    };\n\n    const compilers = [];\n    const compilersWithoutHMR = [];\n    let webpackConfig;\n    if (compiler.compilers) {\n      webpackConfig = [];\n      compiler.compilers.forEach((compiler) => {\n        webpackConfig.push(compiler.options);\n        compilers.push(compiler);\n        if (!findHMRPlugin(compiler.options)) {\n          compilersWithoutHMR.push(compiler);\n        }\n      });\n    } else {\n      webpackConfig = compiler.options;\n      compilers.push(compiler);\n      if (!findHMRPlugin(compiler.options)) {\n        compilersWithoutHMR.push(compiler);\n      }\n    }\n\n    // it's possible that we should clone the config before doing\n    // this, but it seems safe not to since it actually reflects\n    // the changes we are making to the compiler\n    // important: this relies on the fact that addEntries now\n    // prevents duplicate new entries.\n    addEntries(webpackConfig, options);\n    compilers.forEach((compiler) => {\n      const config = compiler.options;\n      compiler.hooks.entryOption.call(config.context, config.entry);\n\n      const providePlugin = new webpack.ProvidePlugin({\n        __webpack_dev_server_client__: getSocketClientPath(options),\n      });\n      providePlugin.apply(compiler);\n    });\n\n    // do not apply the plugin unless it didn't exist before.\n    if (options.hot || options.hotOnly) {\n      compilersWithoutHMR.forEach((compiler) => {\n        // addDevServerEntrypoints above should have added the plugin\n        // to the compiler options\n        const plugin = findHMRPlugin(compiler.options);\n        if (plugin) {\n          plugin.apply(compiler);\n        }\n      });\n    }\n  }\n}\n\nmodule.exports = updateCompiler;\n"]},"metadata":{},"sourceType":"script"}