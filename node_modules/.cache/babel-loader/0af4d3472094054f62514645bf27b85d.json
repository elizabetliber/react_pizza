{"ast":null,"code":"'use strict';\n\nvar Promise = require('pinkie-promise');\n\nvar arrayUnion = require('array-union');\n\nvar objectAssign = require('object-assign');\n\nvar glob = require('glob');\n\nvar pify = require('pify');\n\nvar globP = pify(glob, Promise).bind(glob);\n\nfunction isNegative(pattern) {\n  return pattern[0] === '!';\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction assertPatternsInput(patterns) {\n  if (!patterns.every(isString)) {\n    throw new TypeError('patterns must be a string or an array of strings');\n  }\n}\n\nfunction generateGlobTasks(patterns, opts) {\n  patterns = [].concat(patterns);\n  assertPatternsInput(patterns);\n  var globTasks = [];\n  opts = objectAssign({\n    cache: Object.create(null),\n    statCache: Object.create(null),\n    realpathCache: Object.create(null),\n    symlinks: Object.create(null),\n    ignore: []\n  }, opts);\n  patterns.forEach(function (pattern, i) {\n    if (isNegative(pattern)) {\n      return;\n    }\n\n    var ignore = patterns.slice(i).filter(isNegative).map(function (pattern) {\n      return pattern.slice(1);\n    });\n    globTasks.push({\n      pattern: pattern,\n      opts: objectAssign({}, opts, {\n        ignore: opts.ignore.concat(ignore)\n      })\n    });\n  });\n  return globTasks;\n}\n\nmodule.exports = function (patterns, opts) {\n  var globTasks;\n\n  try {\n    globTasks = generateGlobTasks(patterns, opts);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  return Promise.all(globTasks.map(function (task) {\n    return globP(task.pattern, task.opts);\n  })).then(function (paths) {\n    return arrayUnion.apply(null, paths);\n  });\n};\n\nmodule.exports.sync = function (patterns, opts) {\n  var globTasks = generateGlobTasks(patterns, opts);\n  return globTasks.reduce(function (matches, task) {\n    return arrayUnion(matches, glob.sync(task.pattern, task.opts));\n  }, []);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = function (patterns, opts) {\n  return [].concat(patterns).some(function (pattern) {\n    return glob.hasMagic(pattern, opts);\n  });\n};","map":{"version":3,"sources":["/home/lisa/VSProjects/react-pizza/react_pizza/node_modules/del/node_modules/globby/index.js"],"names":["Promise","require","arrayUnion","objectAssign","glob","pify","globP","bind","isNegative","pattern","isString","value","assertPatternsInput","patterns","every","TypeError","generateGlobTasks","opts","concat","globTasks","cache","Object","create","statCache","realpathCache","symlinks","ignore","forEach","i","slice","filter","map","push","module","exports","err","reject","all","task","then","paths","apply","sync","reduce","matches","hasMagic","some"],"mappings":"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","sourcesContent":["'use strict';\nvar Promise = require('pinkie-promise');\nvar arrayUnion = require('array-union');\nvar objectAssign = require('object-assign');\nvar glob = require('glob');\nvar pify = require('pify');\n\nvar globP = pify(glob, Promise).bind(glob);\n\nfunction isNegative(pattern) {\n\treturn pattern[0] === '!';\n}\n\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\nfunction assertPatternsInput(patterns) {\n\tif (!patterns.every(isString)) {\n\t\tthrow new TypeError('patterns must be a string or an array of strings');\n\t}\n}\n\nfunction generateGlobTasks(patterns, opts) {\n\tpatterns = [].concat(patterns);\n\tassertPatternsInput(patterns);\n\n\tvar globTasks = [];\n\n\topts = objectAssign({\n\t\tcache: Object.create(null),\n\t\tstatCache: Object.create(null),\n\t\trealpathCache: Object.create(null),\n\t\tsymlinks: Object.create(null),\n\t\tignore: []\n\t}, opts);\n\n\tpatterns.forEach(function (pattern, i) {\n\t\tif (isNegative(pattern)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ignore = patterns.slice(i).filter(isNegative).map(function (pattern) {\n\t\t\treturn pattern.slice(1);\n\t\t});\n\n\t\tglobTasks.push({\n\t\t\tpattern: pattern,\n\t\t\topts: objectAssign({}, opts, {\n\t\t\t\tignore: opts.ignore.concat(ignore)\n\t\t\t})\n\t\t});\n\t});\n\n\treturn globTasks;\n}\n\nmodule.exports = function (patterns, opts) {\n\tvar globTasks;\n\n\ttry {\n\t\tglobTasks = generateGlobTasks(patterns, opts);\n\t} catch (err) {\n\t\treturn Promise.reject(err);\n\t}\n\n\treturn Promise.all(globTasks.map(function (task) {\n\t\treturn globP(task.pattern, task.opts);\n\t})).then(function (paths) {\n\t\treturn arrayUnion.apply(null, paths);\n\t});\n};\n\nmodule.exports.sync = function (patterns, opts) {\n\tvar globTasks = generateGlobTasks(patterns, opts);\n\n\treturn globTasks.reduce(function (matches, task) {\n\t\treturn arrayUnion(matches, glob.sync(task.pattern, task.opts));\n\t}, []);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = function (patterns, opts) {\n\treturn [].concat(patterns).some(function (pattern) {\n\t\treturn glob.hasMagic(pattern, opts);\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}